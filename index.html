<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–í—Ä–µ–º–µ–Ω–∞ –∑–∞ –ù–∞–º–∞–∑</title>
    <!-- Web icon (favicon) updated to reference a static file for better compatibility on hosting platforms like GitHub Pages. -->
    <!-- Please ensure you have a 'favicon.png' file in the root directory of your project. -->
    <link rel="icon" href="/favicon.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text color */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0.5rem; /* Reduced overall body padding */
            box-sizing: border-box;
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background for the card */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 1.5rem; /* More rounded corners */
            padding: 1rem; /* Further reduced container padding */
            width: 100%;
            max-width: 480px; /* Default max width for mobile */
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Further reduced gap for better fit */
            box-sizing: border-box; /* Ensure padding is included in element's total width and height */
        }
        /* Responsive max-width for larger screens */
        @media (min-width: 768px) { /* md breakpoint */
            .container {
                max-width: 640px; /* md:max-w-xl */
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            .container {
                max-width: 768px; /* lg:max-w-2xl */
            }
        }

        /* Responsive text sizes for countdown */
        #countdown {
            font-weight: 700;
            color: #a0aec0; /* Lighter grey for time */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            /* Tailwind classes below will handle responsiveness */
        }

        .countdown-text {
            font-size: 1.1rem; /* Slightly smaller for tighter fit */
            font-weight: 500;
            color: #cbd5e0;
            margin-top: 0.25rem; /* Reduced margin */
        }
        .prayer-row {
            display: flex;
            justify-content: space-between; /* Keeps name left, and time/button group right */
            align-items: center;
            padding: 0.5rem 0; /* Reduced padding */
            border-bottom: 1px solid #4a5568; /* Subtle separator */
        }
        .prayer-row:last-child {
            border-bottom: none;
        }
        .prayer-name {
            font-size: 1rem; /* Slightly smaller */
            font-weight: 500;
            color: #cbd5e0;
        }
        .prayer-time {
            font-size: 1.1rem; /* Slightly smaller */
            font-weight: 600;
            color: #a0aec0;
        }
        .highlighted-prayer .prayer-name,
        .highlighted-prayer .prayer-time {
            color: #68d391; /* Highlight color */
            font-weight: 700;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #68d391;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* General button style for action buttons (date, language, adjustments) */
        .action-button {
            background-color: #4a5568;
            color: #e2e8f0;
            border: 1px solid #68d391;
            border-radius: 0.5rem;
            padding: 0.5rem; /* Smaller padding for emoji-only button */
            width: 3rem; /* Fixed width for emoji button */
            height: 3rem; /* Fixed height for emoji button */
            font-size: 1.5rem; /* Larger emoji */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            white-space: nowrap; /* Prevent text wrap for text buttons */
        }
        .action-button:hover {
            background-color: #5a677d;
        }
        .action-button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(104, 211, 145, 0.5);
        }
        /* Specific style for adjustment button that contains text */
        #open-adjustment-modal-btn {
            padding: 0.5rem; /* Adjust padding for emoji only */
            width: 3rem; /* Fixed width for emoji only */
            font-size: 1.5rem; /* Larger font for emoji only */
            gap: 0; /* No gap as there's no text */
        }


        /* Hidden input for date selection */
        .hidden-date-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 0.5rem; /* Reduced padding for modals */
            backdrop-filter: blur(5px); /* Optional: blur background */
        }
        .modal-content {
            background-color: #2d3748;
            border-radius: 1.5rem;
            padding: 1.5rem; /* Reduced padding */
            width: 100%;
            max-width: 400px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            color: #e2e8f0;
            max-height: 95vh; /* Allow slightly more height for modal if needed */
            overflow-y: auto; /* Enable scrolling for long lists inside modal */
        }
        .city-list-item {
            padding: 0.6rem 1rem; /* Reduced padding */
            border-bottom: 1px solid #4a5568;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }
        .city-list-item:hover {
            background-color: #3a475d;
        }
        .city-list-item.selected {
            background-color: #68d391;
            color: #1a202c;
            font-weight: 600;
        }
        .city-list-item:last-child {
            border-bottom: none;
        }

        /* Styles for the new adjustment modal inputs */
        .adjustment-input-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem; /* Reduced margin */
        }
        .adjustment-input-row label {
            font-size: 1rem; /* Slightly smaller */
            font-weight: 500;
            color: #cbd5e0;
        }
        .adjustment-input-row input[type="number"] {
            width: 70px; /* Reduced width */
            text-align: center;
            background-color: #4a5568;
            border: 1px solid #68d391;
            color: #e2e8f0;
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.25rem 0.4rem; /* Reduced padding */
        }
    </style>
</head>
<body class="antialiased">
    <div class="container">
        <!-- Top row: Gregorian Date & Day + Current Time (left), Hijri Date & Sacred Day + Location (right) -->
        <div class="flex justify-between items-start text-sm md:text-base">
            <div id="gregorian-date-info" class="flex flex-col items-start font-medium text-gray-400">
                <span id="current-date"></span>
                <span id="current-day"></span>
                <div id="current-time" class="text-lg font-semibold text-gray-300 mt-1"></div>
            </div>
            <div id="hijri-and-sacred-info" class="flex flex-col items-end text-gray-500">
                <span id="hijri-date"></span>
                <span id="sacred-day-info" class="text-green-400 font-semibold text-xs mt-1"></span>
                <span id="selected-city-display" class="text-gray-400 text-sm mt-1">–°–æ—Ñ–∏—è</span>
            </div>
        </div>

        <div class="text-center flex flex-col items-center">
            <div class="flex items-center justify-center gap-2 mb-1"> <!-- Reduced margin-bottom -->
                <div id="countdown" class="text-4xl md:text-5xl lg:text-6xl font-bold text-gray-400">--:--:--</div>
                <button id="return-today-btn" class="action-button !w-10 !h-10 !text-xl hidden">üîÑ</button> <!-- Slightly smaller button -->
            </div>
            <div id="countdown-text" class="countdown-text">–∑–∞—Ä–µ–∂–¥–∞–Ω–µ...</div>
        </div>
        
        <!-- Loading Indicator -->
        <div id="loading-indicator" class="flex justify-center items-center py-4 hidden"> <!-- Reduced padding -->
            <div class="loading-spinner"></div>
        </div>

        <div id="prayer-times-list" class="flex flex-col gap-1"> <!-- Removed max-height and overflow-y-auto -->
            <!-- Prayer times will be populated here -->
        </div>

        <div id="error-message" class="hidden text-center text-red-400 text-sm mt-2"> <!-- Reduced margin-top -->
            –í—ä–∑–Ω–∏–∫–Ω–∞ –≥—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –≤—Ä–µ–º–µ–Ω–∞—Ç–∞ –∑–∞ –Ω–∞–º–∞–∑. –ú–æ–ª—è, –æ–ø–∏—Ç–∞–π—Ç–µ –æ—Ç–Ω–æ–≤–æ –ø–æ-–∫—ä—Å–Ω–æ.
        </div>

        <!-- New bottom row for action buttons -->
        <div class="flex justify-center md:justify-around items-center mt-4 gap-3"> <!-- Reduced margin-top and gap -->
            <!-- Location Button (emoji only, opens modal) -->
            <button id="location-select-btn" class="action-button">üìç</button>

            <!-- New Sacred Events Button -->
            <button id="open-sacred-events-modal-btn" class="action-button">‚ú®</button>

            <!-- NEW Countdown Toggle Button -->
            <button id="countdown-toggle-btn" class="action-button">‚åõ</button>

            <!-- Date Button (emoji only) -->
            <div class="relative">
                <button id="date-picker-btn" class="action-button">üóìÔ∏è</button>
                <input type="date" id="hidden-date-input" class="hidden-date-input">
            </div>

            <!-- Language Toggle Button -->
            <button id="language-toggle-btn" class="action-button">üí¨</button>

            <!-- Adjustment Button -->
            <button id="open-adjustment-modal-btn" class="action-button">‚öôÔ∏è</button>
        </div>
    </div>

    <!-- City Selection Modal -->
    <div id="city-selection-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-white mb-4">–ò–∑–±–µ—Ä–µ—Ç–µ –≥—Ä–∞–¥</h3>
            <div id="city-list" class="flex flex-col gap-1 mb-4"> <!-- Reduced gap and margin -->
                <!-- City options will be populated here by JavaScript -->
            </div>
            <div class="flex justify-end">
                <button id="close-city-modal-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">–ó–∞—Ç–≤–æ—Ä–∏</button>
            </div>
        </div>
    </div>

    <!-- Global Prayer Adjustment Modal (reworked) -->
    <div id="adjustment-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-white mb-4">–ö–æ—Ä–µ–∫—Ü–∏–∏ –Ω–∞ –≤—Ä–µ–º–µ–Ω–∞ –∑–∞ –Ω–∞–º–∞–∑</h3>
            <p class="text-gray-300 text-sm mb-3">–í—ä–≤–µ–¥–µ—Ç–µ –∫–æ—Ä–µ–∫—Ü–∏—è –≤ –º–∏–Ω—É—Ç–∏ (+ –∑–∞ –Ω–∞–ø—Ä–µ–¥, - –∑–∞ –Ω–∞–∑–∞–¥):</p> <!-- Reduced margin -->
            <div id="prayer-adjustment-inputs" class="mb-4"> <!-- Reduced margin -->
                <!-- Adjustment inputs will be dynamically generated here -->
            </div>
            <div class="flex justify-end space-x-3"> <!-- Reduced space-x -->
                <button id="cancel-adjustment-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">–û—Ç–∫–∞–∑</button>
                <button id="save-all-adjustments-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">–ó–∞–ø–∞–∑–∏</button>
            </div>
        </div>
    </div>

    <!-- Sacred Events Modal -->
    <div id="sacred-events-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-white mb-4">–°–≤–µ—â–µ–Ω–∏ –¥–Ω–∏ –∏ –Ω–æ—â–∏ –∑–∞ <span id="sacred-events-modal-year-display"></span></h3>
            <div class="flex justify-between items-center mb-4">
                <button id="prev-sacred-year-btn" class="action-button !w-10 !h-10 !text-lg">‚¨ÖÔ∏è</button>
                <button id="toggle-sacred-events-countdown-btn" class="action-button">‚è≥</button>
                <button id="open-sacred-event-adjustment-modal-btn" class="action-button">‚öôÔ∏è</button> <!-- New Adjustment button -->
                <button id="next-sacred-year-btn" class="action-button !w-10 !h-10 !text-lg">‚û°Ô∏è</button>
            </div>
            <div id="sacred-events-loading-indicator" class="flex justify-center items-center py-4 hidden">
                <div class="loading-spinner"></div>
            </div>
            <div id="sacred-events-list" class="flex flex-col gap-1 mb-4">
                <!-- Sacred events will be populated here -->
            </div>
            <div class="flex justify-end">
                <button id="close-sacred-events-modal-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">–ó–∞—Ç–≤–æ—Ä–∏</button>
            </div>
        </div>
    </div>

    <!-- Sacred Event Adjustment Modal (NEW) -->
    <div id="sacred-event-adjustment-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-white mb-4">–ö–æ—Ä–µ–∫—Ü–∏–∏ –Ω–∞ –¥–∞—Ç–∏ –∑–∞ —Å–≤–µ—â–µ–Ω–∏ —Å—ä–±–∏—Ç–∏—è</h3>
            <p class="text-gray-300 text-sm mb-3">–í—ä–≤–µ–¥–µ—Ç–µ –∫–æ—Ä–µ–∫—Ü–∏—è –≤ –º–∏–Ω—É—Ç–∏ (+ –∑–∞ –Ω–∞–ø—Ä–µ–¥, - –∑–∞ –Ω–∞–∑–∞–¥). –¢–æ–≤–∞ —â–µ –ø—Ä–æ–º–µ–Ω–∏ –ì—Ä–µ–≥–æ—Ä–∏–∞–Ω—Å–∫–∞—Ç–∞ –¥–∞—Ç–∞, –ø–æ–ª—É—á–µ–Ω–∞ –æ—Ç API, –∑–∞ –¥–∞–¥–µ–Ω–æ –•–∏–¥–∂—Ä–∏ —Å—ä–±–∏—Ç–∏–µ:</p>
            <div id="sacred-event-adjustment-inputs" class="mb-2">
                <!-- Adjustment inputs will be dynamically generated here -->
            </div>
            <p id="sacred-event-adjustment-error-message" class="hidden text-center text-red-400 text-sm mb-3"></p> <!-- NEW: Error message for this modal -->
            <div class="flex justify-end space-x-3">
                <button id="cancel-sacred-event-adjustment-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">–û—Ç–∫–∞–∑</button>
                <button id="save-sacred-event-adjustments-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">–ó–∞–ø–∞–∑–∏</button>
            </div>
        </div>
    </div>

    <script>
        // --- HIJRI SACRED EVENTS DEFINITIONS ---
        // This array defines sacred Islamic events by their Hijri month and day.
        // The display names are in Bulgarian.
        const HIJRI_SACRED_EVENTS = [
            // Regaib Night (often observed on the first Thursday night of Rajab)
            // Aladhan API might provide specific Gregorian dates for this, but standard is 1st Rajab for calendar purposes.
            // For Regaib, it's typically the night leading to the first Friday of Rajab,
            // which can be either the 1st or 2nd of Rajab depending on moon sighting.
            // The sacredDays in the original code pointed to specific Gregorian dates for these.
            // For dynamic determination, we rely on the Hijri date from the API.
            // Based on Diyanet calendars, the dates provided previously were specific.
            // Let's stick to the numerical Hijri dates for the core events.
            { hijriMonthEn: "Rajab", hijriDay: 1, nameBg: "–ù–æ—â—Ç–∞ –Ω–∞ –†–µ–≥–∞–∏–± (1 –†–µ–¥–∂–µ–±)", key: "Regaib" }, // Added unique key for adjustments
            { hijriMonthEn: "Rajab", hijriDay: 27, nameBg: "–ù–æ—â—Ç–∞ –Ω–∞ –ú–∏—Ä–∞–¥–∂ (27 –†–µ–¥–∂–µ–±)", key: "Miraj" },
            { hijriMonthEn: "Sha'ban", hijriDay: 15, nameBg: "–ù–æ—â—Ç–∞ –Ω–∞ –ë–µ—Ä–∞—Ç (15 –®–∞–±–∞–Ω)", key: "Berat" },
            { hijriMonthEn: "Ramadan", hijriDay: 1, nameBg: "–ù–∞—á–∞–ª–æ –Ω–∞ –†–∞–º–∞–∑–∞–Ω (1 –†–∞–º–∞–∑–∞–Ω)", key: "RamadanStart" },
            { hijriMonthEn: "Ramadan", hijriDay: 27, nameBg: "–ù–æ—â—Ç–∞ –ö–∞–¥–∏—Ä (27 –†–∞–º–∞–∑–∞–Ω)", key: "Kadir" }, // Exact date may vary, 27th is common.
            { hijriMonthEn: "Shawwal", hijriDay: 1, nameBg: "–†–∞–º–∞–∑–∞–Ω –ë–∞–π—Ä–∞–º - –î–µ–Ω 1 (1 –®–µ–≤–≤–∞–ª)", key: "RamazanBayram1" },
            { hijriMonthEn: "Shawwal", hijriDay: 2, nameBg: "–†–∞–º–∞–∑–∞–Ω –ë–∞–π—Ä–∞–º - –î–µ–Ω 2 (2 –®–µ–≤–≤–∞–ª)", key: "RamazanBayram2" },
            { hijriMonthEn: "Shawwal", hijriDay: 3, nameBg: "–†–∞–º–∞–∑–∞–Ω –ë–∞–π—Ä–∞–º - –î–µ–Ω 3 (3 –®–µ–≤–≤–∞–ª)", key: "RamazanBayram3" },
            { hijriMonthEn: "Dhul-Hijjah", hijriDay: 9, nameBg: "–î–µ–Ω—è—Ç –ê—Ä–∞—Ñ–∞ (9 –ó–∏–ª—Ö–∏–¥–∂–µ)", key: "Arafa" },
            { hijriMonthEn: "Dhul-Hijjah", hijriDay: 10, nameBg: "–ö—É—Ä–±–∞–Ω –ë–∞–π—Ä–∞–º - –î–µ–Ω 1 (10 –ó–∏–ª—Ö–∏–¥–∂–µ)", key: "KurbanBayram1" },
            { hijriMonthEn: "Dhul-Hijjah", hijriDay: 11, nameBg: "–ö—É—Ä–±–∞–Ω –ë–∞–π—Ä–∞–º - –î–µ–Ω 2 (11 –ó–∏–ª—Ö–∏–¥–∂–µ)", key: "KurbanBayram2" },
            { hijriMonthEn: "Dhul-Hijjah", hijriDay: 12, nameBg: "–ö—É—Ä–±–∞–Ω –ë–∞–π—Ä–∞–º - –î–µ–Ω 3 (12 –ó–∏–ª—Ö–∏–¥–∂–µ)", key: "KurbanBayram3" },
            { hijriMonthEn: "Dhul-Hijjah", hijriDay: 13, nameBg: "–ö—É—Ä–±–∞–Ω –ë–∞–π—Ä–∞–º - –î–µ–Ω 4 (13 –ó–∏–ª—Ö–∏–¥–∂–µ)", key: "KurbanBayram4" },
            { hijriMonthEn: "Muharram", hijriDay: 1, nameBg: "–ù–æ–≤–∞ –•–∏–¥–∂ri –≥–æ–¥–∏–Ω–∞ (1 –ú—É—Ö–∞—Ä—Ä–µ–º)", key: "NewHijriYear" },
            { hijriMonthEn: "Muharram", hijriDay: 10, nameBg: "–ê—à—É—Ä–∞ (10 –ú—É—Ö–∞—Ä—Ä–µ–º)", key: "Ashura" },
            { hijriMonthEn: "Rabi' al-Awwal", hijriDay: 12, nameBg: "–ú–µ–≤–ª–∏–¥ –ö–∞–Ω–¥–∏–ª–ª–∏ (12 –†–∞–±–∏—é–ª–µ–≤–≤–µ–ª)", key: "Mawlid" }
        ];
        // --- END OF HIJRI SACRED EVENTS DEFINITIONS ---


        // DOM Elements
        const currentTimeEl = document.getElementById('current-time');
        const countdownEl = document.getElementById('countdown');
        const countdownTextEl = document.getElementById('countdown-text');
        const currentDateEl = document.getElementById('current-date');
        const currentDayEl = document.getElementById('current-day');
        const hijriDateEl = document.getElementById('hijri-date');
        const sacredDayInfoEl = document.getElementById('sacred-day-info'); 
        const prayerTimesListEl = document.getElementById('prayer-times-list');
        const loadingIndicatorEl = document.getElementById('loading-indicator');
        const errorMessageEl = document.getElementById('error-message');
        const locationSelectBtn = document.getElementById('location-select-btn'); 
        const selectedCityDisplay = document.getElementById('selected-city-display'); 
        const datePickerBtn = document.getElementById('date-picker-btn'); 
        const hiddenDateInput = document.getElementById('hidden-date-input'); 
        const languageToggleBtn = document.getElementById('language-toggle-btn'); 
        const openAdjustmentModalBtn = document.getElementById('open-adjustment-modal-btn'); 
        const countdownToggleButton = document.getElementById('countdown-toggle-btn'); 
        const returnTodayBtn = document.getElementById('return-today-btn'); // New button element

        // Modals and their elements
        const citySelectionModal = document.getElementById('city-selection-modal'); 
        const cityListEl = document.getElementById('city-list');
        const closeCityModalBtn = document.getElementById('close-city-modal-btn');

        const adjustmentModal = document.getElementById('adjustment-modal');
        const prayerAdjustmentInputsContainer = document.getElementById('prayer-adjustment-inputs'); 
        const cancelAdjustmentBtn = document.getElementById('cancel-adjustment-btn');
        const saveAllAdjustmentsBtn = document.getElementById('save-all-adjustments-btn'); 

        // New Sacred Events Modal Elements
        const openSacredEventsModalBtn = document.getElementById('open-sacred-events-modal-btn');
        const sacredEventsModal = document.getElementById('sacred-events-modal');
        const closeSacredEventsModalBtn = document.getElementById('close-sacred-events-modal-btn');
        const sacredEventsModalYearDisplay = document.getElementById('sacred-events-modal-year-display');
        const prevSacredYearBtn = document.getElementById('prev-sacred-year-btn');
        const nextSacredYearBtn = document.getElementById('next-sacred-year-btn');
        const toggleSacredEventsCountdownBtn = document.getElementById('toggle-sacred-events-countdown-btn');
        const sacredEventsListEl = document.getElementById('sacred-events-list');
        const sacredEventsLoadingIndicator = document.getElementById('sacred-events-loading-indicator');

        // Sacred Event Adjustment Modal Elements (NEW)
        const openSacredEventAdjustmentModalBtn = document.getElementById('open-sacred-event-adjustment-modal-btn');
        const sacredEventAdjustmentModal = document.getElementById('sacred-event-adjustment-modal');
        const sacredEventAdjustmentInputsContainer = document.getElementById('sacred-event-adjustment-inputs');
        const cancelSacredEventAdjustmentBtn = document.getElementById('cancel-sacred-event-adjustment-btn');
        const saveSacredEventAdjustmentsBtn = document.getElementById('save-sacred-event-adjustments-btn');
        const sacredEventAdjustmentErrorMessageEl = document.getElementById('sacred-event-adjustment-error-message'); // NEW: Error message for this modal


        // Prayer names in Bulgarian (Dhuhr will be handled conditionally)
        const prayerNamesStandard = {
            Fajr: '–ó–æ—Ä–∞',
            Sunrise: '–ò–∑–≥—Ä–µ–≤',
            Dhuhr: '–û–±–µ–¥–Ω–∞', 
            Asr: '–°–ª–µ–¥–æ–±–µ–¥–Ω–∞',
            Maghrib: '–í–µ—á–µ—Ä–Ω–∞',
            Isha: '–ù–æ—â–Ω–∞'
        };

        const prayerNamesClassical = {
            Fajr: '–ó–∞–≥–æ–≤–µ–≤–∞–Ω–µ', 
            Sunrise: '–ò–∑–≥–∏—Ä–∞–Ω–µ', 
            Dhuhr: '–ü–ª–∞–¥–µ–Ω', 
            Asr: '–ò–∫–∏–Ω–¥–∏–µ', 
            Maghrib: '–ê—à–µ–º', 
            Isha: '–ô–µ—Ü–∏–µ' 
        };

        // All prayer keys for iteration
        const allPrayerKeys = ['Fajr', 'Sunrise', 'Dhuhr', 'Asr', 'Maghrib', 'Isha'];

        // General prayer-specific adjustments in minutes (applied on top of base times)
        const adjustments = {
            Fajr: 0,
            Sunrise: -7,
            Dhuhr: 5,
            Asr: 4,
            Maghrib: 6,
            Isha: 0 
        };

        // Custom city offsets relative to Sofia (minutes to be added/subtracted from Sofia's times)
        // These offsets will now be applied to the API-fetched times for Sofia.
        const cityOffsets = {
            "–°–æ—Ñ–∏—è": 0, // Base city, no offset
            "–ì–æ—Ü–µ –î–µ–ª—á–µ–≤": -1,
            "–Ø–∫–æ—Ä—É–¥–∞": -1,
            "–í–µ–ª–∏–Ω–≥—Ä–∞–¥": -3,
            "–ö–Ω–µ–∂–∞": -3,
            "–õ–æ–≤–µ—á": -5,
            "–°–º–æ–ª—è–Ω": -5,
            "–ü–ª–æ–≤–¥–∏–≤": -5,
            "–ü–ª–µ–≤–µ–Ω": -5,
            "–ú–∞–¥–∞–Ω": -6,
            "–ù–∏–∫–æ–ø–æ–ª": -6,
            "–ö–∞—Ä–ª–æ–≤–æ": -6,
            "–°–≤–∏—â–æ–≤": -8,
            "–ö—ä—Ä–¥–∂–∞–ª–∏": -8,
            "–ö—Ä—É–º–æ–≤–≥—Ä–∞–¥": -9,
            "–í–µ–ª–∏–∫–æ –¢—ä—Ä–Ω–æ–≤–æ": -9,
            "–°—Ç–∞—Ä–∞ –ó–∞–≥–æ—Ä–∞": -9,
            "–•–∞—Å–∫–æ–≤–æ": -9,
            "–ì–æ—Ä–Ω–∞ –û—Ä—è—Ö–æ–≤–∏—Ü–∞": -9,
            "–†—É—Å–µ": -10,
            "–¢–≤—ä—Ä–¥–∏—Ü–∞": -10,
            "–•–∞—Ä–º–∞–Ω–ª–∏": -10,
            "–ù–æ–≤–∞ –ó–∞–≥–æ—Ä–∞": -10,
            "–ö—É–±—Ä–∞—Ç": -12,
            "–†–∞–∑–≥—Ä–∞–¥": -12,
            "–ö–æ—Ç–µ–ª": -12,
            "–°–ª–∏–≤–µ–Ω": -12,
            "–Ø–º–±–æ–ª": -12,
            "–ò—Å–ø–µ—Ä–∏—Ö": -13,
            "–í–µ–ª–∏–∫–∏ –ü—Ä–µ—Å–ª–∞–≤": -13,
            "–¢—ä—Ä–≥–æ–≤–∏—â–µ": -13,
            "–°–∏—Ç–æ–≤–æ": -14,
            "–ö–∞–æ–ª–∏–Ω–æ–≤–æ": -14,
            "–ö–∞—Ä–Ω–æ–±–∞—Ç": -14,
            "–®—É–º–µ–Ω": -14,
            "–ù–æ–≤–∏ –ü–∞–∑–∞—Ä": -15,
            "–ê–π—Ç–æ—Å": -15,
            "–ü—Ä–æ–≤–∞–¥–∏—è": -16,
            "–ë—É—Ä–≥–∞—Å": -16,
            "–°–∏–ª–∏—Å—Ç—Ä–∞": -16,
            "–î–æ–±—Ä–∏—á": -17,
            "–ë—è–ª–∞": -17,
            "–ë–∞–ª—á–∏–∫": -18,
            "–í–∞—Ä–Ω–∞": -18,
            "–ö–∞–≤–∞—Ä–Ω–∞": -19
        };

        // Mapping for Hijri month names to Bulgarian
        const hijriMonthsBg = {
            "Muharram": "–ú—É—Ö–∞—Ä—Ä–µ–º",
            "Safar": "–°–∞—Ñ–µ—Ä",
            "Rabi' al-Awwal": "–†–∞–±–∏—é–ª–µ–≤–≤–µ–ª",
            "Rabi' al-Thani": "–†–∞–±–∏—é–ª–∞—Ö–∏—Ä",
            "Jumada al-Awwal": "–î–∂–µ–º–∞–∑–∏—é–ª–µ–≤–≤–µ–ª",
            "Jumada al-Thani": "–î–∂–µ–º–∞–∑–∏—é–ª–∞—Ö–∏—Ä",
            "Rajab": "–†–µ–¥–∂–µ–±",
            "Sha'ban": "–®–∞–±–∞–Ω",
            "Ramadan": "–†–∞–º–∞–∑–∞–Ω",
            "Shawwal": "–®–µ–≤–≤–∞–ª",
            "Dhul-Qadah": "–ó–∏–ª–∫–∞–¥–µ",
            "Dhul-Hijjah": "–ó–∏–ª—Ö–∏–¥–∂–µ"
        };

        let prayerTimes = {}; // Stores fetched prayer times (after all adjustments for selected city)
        let nextPrayerIndex = -1; // Index of the next prayer in the list
        let selectedCity = "–°–æ—Ñ–∏—è"; // Default selected city
        let currentHijriDate = ''; // To store and display Hijri date
        let selectedDate = new Date(); // Stores the currently selected date (defaults to today)
        let customPrayerAdjustments = {}; // Stores user-defined adjustments for each prayer {Fajr: 5, Dhuhr: -2}
        let isClassicalNamesActive = false; // State for naming convention
        let isCountdownMode = false; // State for countdown mode in prayer list

        // New state for Sacred Events Modal
        let sacredEventsModalYear = new Date().getFullYear(); // Default to current Gregorian year for the modal
        let isSacredEventsCountdownMode = false; // Toggle for countdown/date display in sacred events modal
        const hijriGregorianCache = {}; // Cache for Hijri to Gregorian conversions
        let customSacredEventAdjustments = {}; // Stores user-defined adjustments for sacred event dates {key: 5}


        // Global variable for the individual prayer countdown interval
        let individualCountdownIntervalId = null;
        // Global array to store prayer data with Date objects for dynamic updates
        let prayersDataForDisplay = []; 
        // Global array to store sacred events data with Date objects for dynamic display
        let eventsToToogleDisplay = [];
        let sacredEventsCountdownIntervalId = null; // Interval for sacred events countdown


        // Get current prayer names based on state
        function getCurrentPrayerNames() {
            return isClassicalNamesActive ? prayerNamesClassical : prayerNamesStandard;
        }

        // Populate city list in modal
        function populateCityList() {
            cityListEl.innerHTML = ''; // Clear previous list
            const sortedCities = Object.keys(cityOffsets).sort((a, b) => {
                if (a === "–°–æ—Ñ–∏—è") return -1;
                if (b === "–°–æ—Ñ–∏—è") return 1;
                return a.localeCompare(b);
            });

            sortedCities.forEach(city => {
                const cityItem = document.createElement('div');
                cityItem.className = 'city-list-item';
                if (city === selectedCity) {
                    cityItem.classList.add('selected');
                }
                cityItem.textContent = city;
                cityItem.dataset.city = city;
                cityItem.addEventListener('click', () => {
                    selectedCity = city;
                    selectedCityDisplay.textContent = selectedCity; // Update display text for selected city
                    closeCitySelectionModal();
                    fetchPrayerTimes(); // Re-fetch times for the new city
                    saveSettings(); // Automatically save city change
                });
                cityListEl.appendChild(cityItem);
            });
        }

        // Function to format time to HH:MM
        function formatTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // Function to format duration (for countdown mode in list)
        function formatDuration(milliseconds) {
            let prefix = '';
            if (milliseconds < 0) {
                prefix = '-';
                milliseconds = Math.abs(milliseconds); // Use absolute value for calculation
            }

            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            let timeParts = [];
            
            // Always include hours, minutes, and seconds, padded to two digits.
            timeParts.push(`${String(hours).padStart(2, '0')}—á`);
            timeParts.push(`${String(minutes).padStart(2, '0')}–º`);
            timeParts.push(`${String(seconds).padStart(2, '0')}—Å`);

            let timeDisplay = timeParts.join(' ');
            
            return prefix + timeDisplay.trim(); 
        }


        // Function to format date to DD.MM.YYYY
        function formatDate(date) {
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
            const year = date.getFullYear();
            return `${day}.${month}.${year}`;
        }

        // Function to format date to WHICH-MM-DD for input type="date" and API calls
        function formatDateForInputAndLookup(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Function to get day of the week in Bulgarian
        function getDayNameBg(date) {
            const days = ['–ù–µ–¥–µ–ª—è', '–ü–æ–Ω–µ–¥–µ–ª–Ω–∏–∫', '–í—Ç–æ—Ä–Ω–∏–∫', '–°—Ä—è–¥–∞', '–ß–µ—Ç–≤—ä—Ä—Ç—ä–∫', '–ü–µ—Ç—ä–∫', '–°—ä–±–æ—Ç–∞'];
            return days[date.getDay()];
        }

        // Function to determine Dhuhr name based on day of the week and current naming style
        function getDhuhrName(date) {
            if (date.getDay() === 5) { // Friday
                return isClassicalNamesActive ? "–î–∂—É–º–∞–π–æ" : "–î–∂—É–º–∞"; 
            }
            return isClassicalNamesActive ? "–ü–ª–∞–¥–µ–Ω" : "–û–±–µ–¥–Ω–∞";
        }

        // Function to update the current time display
        function updateClock() {
            const now = new Date();
            currentTimeEl.textContent = formatTime(now);
        }

        // Function to fetch Hijri date for a given Gregorian date using Aladhan API
        // This is primarily used by findGregorianDateOfHijri to get Hijri equivalent for a Gregorian day.
        async function getHijriDateForGregorian(year, month, day) {
            const gregorianDate = `${String(day).padStart(2, '0')}-${String(month).padStart(2, '0')}-${year}`;
            const apiUrl = `https://api.aladhan.com/v1/timingsByCity/${gregorianDate}?city=Sofia&country=Bulgaria&method=10`; // Using Sofia for conversion base

            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = await response.json();
                if (data.data && data.data.date && data.data.date.hijri) {
                    return data.data.date.hijri; // Returns an object like { day: "1", month: { en: "Ramadan" }, year: "1446" }
                } else {
                    console.warn("Could not retrieve Hijri date from API for", gregorianDate);
                    return null;
                }
            } catch (error) {
                console.error("Error fetching Hijri date:", error);
                return null;
            }
        }

        // Function to find the Gregorian date of a specific Hijri date,
        // optionally within a specific Gregorian year hint.
        // This function is computationally intensive as it iterates through Gregorian dates
        // and makes API calls for conversion. Caching is crucial to prevent excessive API calls.
        async function findGregorianDateOfHijri(targetHijriMonthEnglish, targetHijriDay, targetHijriYear, gregorianYearHint) {
            const cacheKey = `${targetHijriMonthEnglish}-${targetHijriDay}-${targetHijriYear}-${gregorianYearHint}`;
            if (hijriGregorianCache[cacheKey]) {
                return new Date(hijriGregorianCache[cacheKey]); // Return cached date object
            }

            let foundDate = null;
            const maxAttemptsPerYear = 366; // Max days in a year to prevent infinite loop

            // Adjust the search range based on a rough estimate for the Hijri year (Gregorian year - 621 or -622)
            // This makes the search more targeted.
            let potentialGregorianYears = new Set();
            potentialGregorianYears.add(gregorianYearHint);
            potentialGregorianYears.add(gregorianYearHint -1); // Check previous Gregorian year as Hijri year can span across
            potentialGregorianYears.add(gregorianYearHint + 1); // Check next Gregorian year

            for (const searchGregorianYear of [...potentialGregorianYears].sort()) { // Sort to be consistent
                let attempts = 0;
                // Start from a reasonable Gregorian month (e.g., January)
                for (let month = 1; month <= 12 && attempts < maxAttemptsPerYear; month++) {
                    for (let day = 1; day <= 31 && attempts < maxAttemptsPerYear; day++) {
                        attempts++;
                        const testDate = new Date(searchGregorianYear, month - 1, day);
                        // Ensure the date is valid and doesn't overflow to another month/year
                        if (isNaN(testDate.getTime()) || testDate.getFullYear() !== searchGregorianYear || testDate.getMonth() !== (month - 1)) {
                            continue;
                        }

                        const hijriDateInfo = await getHijriDateForGregorian(testDate.getFullYear(), testDate.getMonth() + 1, testDate.getDate());

                        if (hijriDateInfo) {
                            if (parseInt(hijriDateInfo.day) === targetHijriDay && 
                                hijriDateInfo.month.en === targetHijriMonthEnglish &&
                                parseInt(hijriDateInfo.year) === targetHijriYear) {
                                foundDate = testDate;
                                break; // Found it
                            }
                        }
                    }
                    if (foundDate) break;
                }
                if (foundDate) break;
            }

            if (foundDate) {
                hijriGregorianCache[cacheKey] = foundDate.toISOString(); // Cache as ISO string
            }
            return foundDate;
        }


        // Function to fetch prayer times from API
        async function fetchPrayerTimes() {
            // Show loading indicator
            loadingIndicatorEl.classList.remove('hidden');
            errorMessageEl.classList.add('hidden'); 
            prayerTimesListEl.innerHTML = ''; // Clear previous times

            // Clear any running individual countdowns before fetching new data
            clearInterval(individualCountdownIntervalId);
            individualCountdownIntervalId = null;

            const currentDateStringForAPI = `${String(selectedDate.getDate()).padStart(2, '0')}-${String(selectedDate.getMonth() + 1).padStart(2, '0')}-${selectedDate.getFullYear()}`;

            // Update Gregorian date and day display
            currentDateEl.textContent = formatDate(selectedDate);
            currentDayEl.textContent = getDayNameBg(selectedDate);
            selectedCityDisplay.textContent = selectedCity; // Update the selected city display

            // Fetch base times for Sofia using Diyanet method (method=10)
            const diyanetApiUrl = `https://api.aladhan.com/v1/timingsByCity/${currentDateStringForAPI}?city=Sofia&country=Bulgaria&method=10`;
            
            // Fetch Isha time specifically using Muslim World League method (method=3)
            const mwlIshaApiUrl = `https://api.aladhan.com/v1/timingsByCity/${currentDateStringForAPI}?city=Sofia&country=Bulgaria&method=3`;

            try {
                const [diyanetResponse, mwlIshaResponse] = await Promise.all([
                    fetch(diyanetApiUrl),
                    fetch(mwlIshaApiUrl)
                ]);

                if (!diyanetResponse.ok || !mwlIshaResponse.ok) {
                    throw new Error(`HTTP error! Statuses: Diyanet ${diyanetResponse.status}, MWL ${mwlIshaResponse.status}`);
                }

                const diyanetData = await diyanetResponse.json();
                const mwlIshaData = await mwlIshaResponse.json();

                // Check for essential data for prayer times calculation
                if (!diyanetData.data || !diyanetData.data.timings || !mwlIshaData.data || !mwlIshaData.data.timings) {
                    throw new Error('–ù–µ–≤–∞–ª–∏–¥–µ–Ω –æ—Ç–≥–æ–≤–æ—Ä –æ—Ç API –∏–ª–∏ –ª–∏–ø—Å–≤–∞—â–∏ –æ—Å–Ω–æ–≤–Ω–∏ –¥–∞–Ω–Ω–∏ –∑–∞ –≤—Ä–µ–º–µ–Ω–∞ –∑–∞ –Ω–∞–º–∞–∑.');
                }

                // Now proceed with prayer time calculation
                const sofiaBaseTimings = {
                    Fajr: diyanetData.data.timings.Fajr,
                    Sunrise: diyanetData.data.timings.Sunrise,
                    Dhuhr: diyanetData.data.timings.Dhuhr,
                    Asr: diyanetData.data.timings.Asr,
                    Maghrib: diyanetData.data.timings.Maghrib,
                    Isha: mwlIshaData.data.timings.Isha // Override Isha with MWL time
                };

                const currentCityCustomOffset = cityOffsets[selectedCity] || 0;
                const adjustedPrayerTimes = {};

                // Apply general and city-specific offsets to the API-fetched Sofia times
                for (const key of allPrayerKeys) { // Iterate through allPrayerKeys for consistent order
                    if (sofiaBaseTimings.hasOwnProperty(key)) {
                        let [hour, minute] = sofiaBaseTimings[key].split(':').map(Number);
                        let tempDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), hour, minute, 0);

                        // Apply general prayer-specific adjustment
                        if (adjustments[key] !== undefined) { 
                            tempDate.setMinutes(tempDate.getMinutes() + adjustments[key]);
                        }
                        // Apply city-specific custom offset
                        tempDate.setMinutes(tempDate.getMinutes() + currentCityCustomOffset);

                        // Apply custom user adjustment (from local storage)
                        if (customPrayerAdjustments[key] !== undefined) {
                            tempDate.setMinutes(tempDate.getMinutes() + customPrayerAdjustments[key]);
                        }

                        adjustedPrayerTimes[key] = formatTime(tempDate);
                    }
                }
                
                prayerTimes = adjustedPrayerTimes; // Store the fully adjusted times

                // Handle Hijri date separately with its own checks for robustness
                if (diyanetData.data.date && diyanetData.data.date.hijri) {
                    const hijri = diyanetData.data.date.hijri;
                    if (hijri.day && hijri.month && hijri.month.en && hijri.year) {
                        const hijriDay = hijri.day;
                        const hijriMonthEnglish = hijri.month.en;
                        const hijriYear = hijri.year;
                        const hijriMonthBg = hijriMonthsBg[hijriMonthEnglish] || hijriMonthEnglish; 
                        currentHijriDate = `${hijriDay} ${hijriMonthBg} ${hijriYear} –≥.`; 
                        hijriDateEl.textContent = currentHijriDate;

                        // --- NEW: Check and display sacred day/night using HIJRI_SACRED_EVENTS ---
                        let foundSacredDay = '';
                        // Iterate over HIJRI_SACRED_EVENTS to find a match for the current Hijri date
                        for (const event of HIJRI_SACRED_EVENTS) {
                            // Convert hijri.day to number for comparison
                            const currentHijriDayNum = parseInt(hijri.day);

                            if (event.hijriMonthEn === hijri.month.en) {
                                // Specific day match
                                if (event.hijriDay === currentHijriDayNum) {
                                    foundSacredDay = event.nameBg;
                                    break;
                                }
                                // Handle ranges if needed (e.g., Ramazan Bayram 1-3 Shawwal, Kurban Bayram 10-13 Dhul-Hijjah)
                                // This requires explicit range checks if a single event definition covers multiple days.
                                // For now, the HIJRI_SACRED_EVENTS are defined per day, making direct matching simpler.
                            }
                        }

                        if (foundSacredDay) {
                            sacredDayInfoEl.textContent = foundSacredDay; 
                            sacredDayInfoEl.classList.remove('hidden');
                        } else {
                            sacredDayInfoEl.textContent = '';
                            sacredDayInfoEl.classList.add('hidden');
                        }
                        // --- END NEW SACRED DAY CHECK ---

                    } else {
                        console.warn("Hijri date data incomplete from API response.");
                        currentHijriDate = '–ù—è–º–∞ —Ö–∏–¥–∂—Ä–∏ –¥–∞—Ç–∞';
                        hijriDateEl.textContent = currentHijriDate;
                        sacredDayInfoEl.textContent = ''; // Clear sacred day info
                        sacredDayInfoEl.classList.add('hidden');
                    }
                } else {
                    console.warn("Hijri date object missing from API response.");
                    currentHijriDate = '–ù—è–º–∞ —Ö–∏–¥–∂—Ä–∏ –¥–∞—Ç–∞';
                    hijriDateEl.textContent = currentHijriDate;
                    sacredDayInfoEl.textContent = ''; // Clear sacred day info
                    sacredDayInfoEl.classList.add('hidden');
                }

                displayPrayerTimes(); // Call display to render and manage countdowns
                
            } catch (error) {
                console.error('Error fetching prayer times:', error);
                errorMessageEl.classList.remove('hidden');
                errorMessageEl.textContent = `–í—ä–∑–Ω–∏–∫–Ω–∞ –≥—Ä–µ—à–∫–∞ –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –≤—Ä–µ–º–µ–Ω–∞—Ç–∞ –∑–∞ –Ω–∞–º–∞–∑: ${error.message}. –ú–æ–ª—è, –ø—Ä–æ–≤–µ—Ä–µ—Ç–µ –≤—Ä—ä–∑–∫–∞—Ç–∞ —Å–∏ –∏ –æ–ø–∏—Ç–∞–π—Ç–µ –æ—Ç–Ω–æ–≤–æ.`;
                prayerTimes = {};
                prayerTimesListEl.innerHTML = '';
                hijriDateEl.textContent = '';
                sacredDayInfoEl.textContent = '';
                sacredDayInfoEl.classList.add('hidden');
            } finally {
                // Hide loading indicator
                loadingIndicatorEl.classList.add('hidden');
            }
        }

        // Function to display prayer times in the list
        function displayPrayerTimes() {
            prayerTimesListEl.innerHTML = ''; // Clear previous times

            const now = new Date(); // Current time for initial comparison
            const targetDate = selectedDate; 
            
            prayersDataForDisplay = []; // Clear and repopulate global array

            const currentPrayerNames = getCurrentPrayerNames();

            for (const key of allPrayerKeys) { 
                if (prayerTimes.hasOwnProperty(key)) {
                    const [hour, minute] = prayerTimes[key].split(':').map(Number);
                    let prayerDate = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), hour, minute, 0);

                    let displayName = currentPrayerNames[key] || key;
                    if (key === 'Dhuhr') {
                        displayName = getDhuhrName(targetDate); 
                    }

                    prayersDataForDisplay.push({
                        name: key,
                        displayName: displayName,
                        staticTime: formatTime(prayerDate), // Store static formatted time
                        date: prayerDate // Store the actual Date object for countdowns
                    });
                }
            }

            // Sort prayers by time to ensure correct order
            prayersDataForDisplay.sort((a, b) => a.date.getTime() - b.date.getTime());

            // --- START FIX: Separate highlighting logic from main countdown nextPrayerIndex ---
            let highlightIndex = -1; // Use a separate variable for highlighting

            if (selectedDate.toDateString() === new Date().toDateString()) {
                // Only highlight if it's today's date
                for (let i = 0; i < prayersDataForDisplay.length; i++) {
                    if (prayersDataForDisplay[i].date > now) { 
                        highlightIndex = i; // Found a future prayer on current day to highlight
                        break;
                    }
                }
                // If all prayers for today have passed, highlightIndex will remain -1,
                // meaning no prayer will be highlighted, which is the desired behavior.
            } else {
                // For past or future selected dates, no highlighting should occur.
                highlightIndex = -1; 
            }
            // --- END FIX ---

            // Render prayer times initially with static times
            prayersDataForDisplay.forEach((prayer, index) => {
                const prayerRow = document.createElement('div');
                prayerRow.className = 'prayer-row';

                // Apply highlighting based on the separate highlightIndex
                if (index === highlightIndex) {
                    prayerRow.classList.add('highlighted-prayer');
                }

                // Render with static time. Dynamic updates will override this if countdown mode is active.
                prayerRow.innerHTML = `
                    <span class="prayer-name">${prayer.displayName}</span>
                    <div class="flex items-center">
                        <span class="prayer-time" id="prayer-time-${prayer.name}">${prayer.staticTime}</span>
                    </div>
                `;
                prayerTimesListEl.appendChild(prayerRow);
            });

            startStopIndividualCountdowns(); // Manage the individual countdown interval
            updateCountdown(); // Update the main countdown (to next prayer)
        }

        // Function to start or stop individual prayer countdowns in the list
        function startStopIndividualCountdowns() {
            clearInterval(individualCountdownIntervalId); // Always clear any existing interval first
            individualCountdownIntervalId = null;

            if (isCountdownMode && selectedDate.toDateString() === new Date().toDateString()) {
                // If in countdown mode AND it's today's date, start the dynamic updates
                updateIndividualCountdowns(); // Call once immediately to set initial countdowns
                individualCountdownIntervalId = setInterval(updateIndividualCountdowns, 1000);
            } else {
                // If not in countdown mode or not today's date, ensure static times are displayed.
                // This loop ensures that if we switch OFF countdown mode, the times revert to static.
                prayersDataForDisplay.forEach(prayer => {
                    const span = document.getElementById(`prayer-time-${prayer.name}`);
                    if (span) {
                        span.textContent = prayer.staticTime; // Revert to static time
                    }
                });
            }
        }

        // Function to dynamically update individual prayer countdowns in the list
        function updateIndividualCountdowns() {
            // This function is only called if isCountdownMode is true and selectedDate is today's date
            const now = new Date();
            prayersDataForDisplay.forEach(prayer => {
                const span = document.getElementById(`prayer-time-${prayer.name}`);
                if (span) {
                    const diffMs = prayer.date.getTime() - now.getTime();
                    span.textContent = formatDuration(diffMs);
                }
            });
        }

        // Helper function to calculate year, month, and day difference between two dates
        function getYearsMonthsDaysDifference(d1, d2) { // d1 = start date (now), d2 = end date (selectedDate)
            let years = d2.getFullYear() - d1.getFullYear();
            let months = d2.getMonth() - d1.getMonth();
            let days = d2.getDate() - d1.getDate();

            // Adjust for negative days (d2.getDate() < d1.getDate())
            if (days < 0) {
                months--;
                // Get the number of days in the month *before* d2's month in d2's year
                let daysInPrevMonthOfD2 = new Date(d2.getFullYear(), d2.getMonth(), 0).getDate();
                days += daysInPrevMonthOfD2;
            }

            // Adjust for negative months (d2.getMonth() < d1.getMonth())
            if (months < 0) {
                years--;
                months += 12;
            }

            return { years, months, days };
        }

        // Function to update the countdown to the next prayer (main countdown)
        function updateCountdown() {
            const now = new Date();

            if (selectedDate.toDateString() !== now.toDateString()) {
                // Handle future/past selected dates
                const diff = getYearsMonthsDaysDifference(now, selectedDate);
                let displayMessage = '';
                returnTodayBtn.classList.remove('hidden'); // Show return to today button

                if (selectedDate > now) { // Future date
                    if (diff.years > 0) {
                        displayMessage += `—Å–ª–µ–¥ ${diff.years} –≥.`;
                        if (diff.months > 0) {
                            displayMessage += ` ${diff.months} –º.`;
                        }
                    } else if (diff.months > 0) {
                        displayMessage += `—Å–ª–µ–¥ ${diff.months} –º.`;
                        if (diff.days > 0) {
                            displayMessage += ` ${diff.days} –¥–Ω–∏`;
                        }
                    } else if (diff.days > 0) {
                        displayMessage += `—Å–ª–µ–¥ ${diff.days} –¥–Ω–∏`;
                    } else { // Very close future, within the same day's times
                        // This case should ideally be handled by the "today's date" logic if `selectedDate` is literally today.
                        // If it's a future date that's just a few hours/minutes away but still on *this* specific date,
                        // we can show a placeholder or transition to the "today" logic.
                        countdownEl.textContent = '--:--:--'; // No ticking countdown for conceptual future dates
                        countdownTextEl.textContent = '–ò–∑–±—Ä–∞–Ω–∞ –µ –±—ä–¥–µ—â–∞ –¥–∞—Ç–∞.'; 
                        return; // Exit as this is not today's ticking countdown
                    }
                    countdownEl.textContent = '--:--:--'; // No ticking countdown for conceptual future dates
                    countdownTextEl.textContent = displayMessage || '–ò–∑–±–µ—Ä–µ—Ç–µ –¥–∞—Ç–∞.'; // Fallback
                } else { // Past date
                    countdownEl.textContent = '--:--:--';
                    countdownTextEl.textContent = '–ò–∑–±—Ä–∞–Ω–∞ –µ –º–∏–Ω–∞–ª–∞ –¥–∞—Ç–∞.';
                }
                return; // Exit as this is not today's countdown
            }

            // If selectedDate IS today's date, proceed with normal countdown logic
            returnTodayBtn.classList.add('hidden'); // Hide return to today button

            if (Object.keys(prayerTimes).length === 0) {
                countdownEl.textContent = '--:--:--';
                countdownTextEl.textContent = '–ù—è–º–∞ –æ—Ç–±—Ä–æ—è–≤–∞–Ω–µ –∑–∞ –∏–∑–±—Ä–∞–Ω–∞—Ç–∞ –¥–∞—Ç–∞.';
                return;
            }

            let nextPrayerTimeDate;
            let nextPrayerDisplayName;

            // Use the already prepared prayersDataForDisplay to find the next prayer
            // No need to re-fetch API data here
            
            let prayersArrayForCountdown = prayersDataForDisplay; // Use the globally available data

            nextPrayerIndex = -1; 
            for (let i = 0; i < prayersArrayForCountdown.length; i++) {
                if (prayersArrayForCountdown[i].date > now) {
                    nextPrayerIndex = i;
                    break;
                    }
                }
            
            if (nextPrayerIndex === -1 && prayersArrayForCountdown.length > 0) {
                // All prayers for today have passed. Set nextPrayerIndex to 0 for tomorrow's Fajr countdown.
                nextPrayerIndex = 0; 
                const nextDayFajr = new Date(prayersArrayForCountdown[0].date);
                nextDayFajr.setDate(nextDayFajr.getDate() + 1);
                nextPrayerTimeDate = nextDayFajr;
                nextPrayerDisplayName = prayersArrayForCountdown[0].displayName;
                countdownTextEl.textContent = `–¥–æ ${nextPrayerDisplayName} —É—Ç—Ä–µ`;
            } else if (nextPrayerIndex !== -1) {
                const nextPrayer = prayersArrayForCountdown[nextPrayerIndex];
                nextPrayerTimeDate = nextPrayer.date;
                nextPrayerDisplayName = nextPrayer.displayName;
                countdownTextEl.textContent = `–¥–æ ${nextPrayerDisplayName}`;
            } else {
                countdownEl.textContent = '00:00:00';
                countdownTextEl.textContent = '–í—Å–∏—á–∫–∏ –Ω–∞–º–∞–∑–∏ –∑–∞ –¥–Ω–µ—Å —Å–∞ –º–∏–Ω–∞–ª–∏.';
                return;
            }

            const diff = nextPrayerTimeDate.getTime() - now.getTime();

            if (diff <= 0) {
                countdownEl.textContent = '00:00:00';
                countdownTextEl.textContent = '–ù–∞–º–∞–∑—ä—Ç –µ —Å–µ–≥–∞!';
                fetchPrayerTimes(); 
                return;
            }

            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            countdownEl.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Function to return to today's date
        function returnToToday() {
            selectedDate = new Date();
            hiddenDateInput.value = formatDateForInputAndLookup(selectedDate);
            fetchPrayerTimes(); // Re-fetch to display times for today
        }

        // --- Modals Logic ---

        // Global Prayer Adjustment Modal
        function openAdjustmentModal() {
            prayerAdjustmentInputsContainer.innerHTML = ''; // Clear previous inputs
            const currentPrayerNames = getCurrentPrayerNames();

            allPrayerKeys.forEach(key => {
                const adjustmentValue = customPrayerAdjustments[key] !== undefined ? customPrayerAdjustments[key] : 0;
                const displayName = currentPrayerNames[key] || key; // Use current language
                const dhuhrDisplayName = key === 'Dhuhr' ? getDhuhrName(new Date()) : displayName; // Special handling for Dhuhr

                const inputRow = document.createElement('div');
                inputRow.className = 'adjustment-input-row';
                inputRow.innerHTML = `
                    <label for="adj-${key}">${dhuhrDisplayName}:</label>
                    <input type="number" id="adj-${key}" data-prayer-key="${key}" value="${adjustmentValue}" class="shadow appearance-none border rounded-lg py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-600 border-gray-500 text-white" placeholder="–ù–∞–ø—Ä. 5 –∏–ª–∏ -3">
                `;
                prayerAdjustmentInputsContainer.appendChild(inputRow);
            });
            
            adjustmentModal.classList.remove('hidden');
        }

        function closeAdjustmentModal() {
            adjustmentModal.classList.add('hidden');
            errorMessageEl.classList.add('hidden'); // Clear error message when closing modal
        }

        function saveAllAdjustments() {
            let changesMade = false;
            let hasInvalidInput = false; // Flag to track if any input is invalid
            allPrayerKeys.forEach(key => {
                const inputElement = document.getElementById(`adj-${key}`);
                if (inputElement) {
                    const newOffset = parseInt(inputElement.value, 10);
                    if (isNaN(newOffset)) {
                        errorMessageEl.textContent = `–ù–µ–≤–∞–ª–∏–¥–Ω–æ —á–∏—Å–ª–æ –∑–∞ –∫–æ—Ä–µ–∫—Ü–∏—è –Ω–∞ ${getCurrentPrayerNames()[key] || key}. –ú–æ–ª—è, –≤—ä–≤–µ–¥–µ—Ç–µ –≤–∞–ª–∏–¥–Ω–æ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä. 5 –∏–ª–∏ -3).`;
                        errorMessageEl.classList.remove('hidden');
                        hasInvalidInput = true; // Set flag
                        return; // Do not process further for this invalid input, but continue checking others
                    }

                    if (customPrayerAdjustments[key] !== newOffset) {
                        customPrayerAdjustments[key] = newOffset;
                        changesMade = true;
                    }
                }
            });

            // Only close modal and save if no invalid inputs were found
            if (!hasInvalidInput) {
                if (changesMade) {
                    saveSettings(); // Automatically save all updated adjustments
                    fetchPrayerTimes(); // Re-fetch and display with new custom adjustments
                }
                closeAdjustmentModal();
            }
            // If there's an invalid input, the modal stays open with the error message displayed.
        }


        // Functions for City Selection Modal
        function openCitySelectionModal() {
            populateCityList(); // Populate list before opening
            citySelectionModal.classList.remove('hidden');
        }

        function closeCitySelectionModal() {
            citySelectionModal.classList.add('hidden');
        }

        // --- Sacred Events Modal Logic ---
        async function openSacredEventsModal() {
            sacredEventsModalYear = new Date().getFullYear(); // Reset to current Gregorian year each time it opens
            await populateSacredEventsList(sacredEventsModalYear);
            sacredEventsModal.classList.remove('hidden');
        }

        function closeSacredEventsModal() {
            sacredEventsModal.classList.add('hidden');
            clearInterval(sacredEventsCountdownIntervalId); // Stop countdown when modal closes
            sacredEventsCountdownIntervalId = null;
        }

        // Function to populate the list of sacred events in the modal
        async function populateSacredEventsList(year) {
            sacredEventsListEl.innerHTML = ''; // Clear previous list
            sacredEventsLoadingIndicator.classList.remove('hidden'); // Show loading spinner
            sacredEventsModalYearDisplay.textContent = year; // Update year display

            const eventsToDisplay = [];

            // Iterate over HIJRI_SACRED_EVENTS and find their Gregorian dates for the target year
            // This relies on the inefficient findGregorianDateOfHijri, but caching is used.
            for (const event of HIJRI_SACRED_EVENTS) {
                // Estimate the Hijri year that likely falls within the Gregorian 'year'
                // A Gregorian year typically overlaps with two Hijri years.
                const estimatedHijriYear1 = year - 621; // Common approximation
                const estimatedHijriYear2 = year - 622; // Another common approximation for the previous Hijri year

                let gregorianDate = null;

                // Try finding the Gregorian date for both estimated Hijri years
                // and pick the one that falls within the `year`
                let foundInYear1 = await findGregorianDateOfHijri(event.hijriMonthEn, event.hijriDay, estimatedHijriYear1, year);
                if (foundInYear1 && foundInYear1.getFullYear() === year) {
                    gregorianDate = foundInYear1;
                } else {
                    let foundInYear2 = await findGregorianDateOfHijri(event.hijriMonthEn, event.hijriDay, estimatedHijriYear2, year);
                    if (foundInYear2 && foundInYear2.getFullYear() === year) {
                        gregorianDate = foundInYear2;
                    }
                }
                
                if (gregorianDate) {
                    // Apply custom sacred event adjustment
                    const adjustmentForEvent = customSacredEventAdjustments[event.key] || 0;
                    gregorianDate.setMinutes(gregorianDate.getMinutes() + adjustmentForEvent);

                    eventsToDisplay.push({
                        name: event.nameBg,
                        date: gregorianDate,
                        key: event.key // Keep the key for adjustments
                    });
                }
            }

            eventsToDisplay.sort((a, b) => a.date.getTime() - b.date.getTime()); // Sort by Gregorian date

            if (eventsToDisplay.length === 0) {
                sacredEventsListEl.innerHTML = '<div class="text-center text-gray-400 py-4">–ù—è–º–∞ –Ω–∞–º–µ—Ä–µ–Ω–∏ —Å–≤–µ—â–µ–Ω–∏ —Å—ä–±–∏—Ç–∏—è –∑–∞ —Ç–∞–∑–∏ –≥–æ–¥–∏–Ω–∞.</div>';
            } else {
                eventsToToogleDisplay = eventsToDisplay; // Store for toggling countdown/date
                renderSacredEventsListDisplay(); // Initial render
            }
            sacredEventsLoadingIndicator.classList.add('hidden'); // Hide loading spinner
        }

        // Function to render or update the sacred events list display (date or countdown)
        function renderSacredEventsListDisplay() {
            sacredEventsListEl.innerHTML = ''; // Clear previous list

            // Stop any existing countdown for sacred events before re-rendering
            clearInterval(sacredEventsCountdownIntervalId);
            sacredEventsCountdownIntervalId = null;

            eventsToToogleDisplay.forEach(event => {
                const eventRow = document.createElement('div');
                eventRow.className = 'prayer-row'; // Reuse prayer-row style

                const now = new Date();
                const displayValue = isSacredEventsCountdownMode ? formatDuration(event.date.getTime() - now.getTime()) : formatDate(event.date);

                // Highlight if the event is today and in countdown mode
                if (isSacredEventsCountdownMode && event.date.toDateString() === now.toDateString()) {
                     eventRow.classList.add('highlighted-prayer'); // Reuse highlight style
                } else if (!isSacredEventsCountdownMode && event.date < now) {
                    // Optional: Dim past dates when showing static dates
                    eventRow.classList.add('opacity-50');
                }

                // Add a unique ID to the span for individual updates in countdown mode
                const uniqueId = `sacred-event-time-${event.key}`; // Use event.key for ID, it's simpler and unique
                eventRow.innerHTML = `
                    <span class="prayer-name">${event.name}</span>
                    <span class="prayer-time" id="${uniqueId}">${displayValue}</span>
                `;
                sacredEventsListEl.appendChild(eventRow);
            });

            if (isSacredEventsCountdownMode) {
                // Start interval for countdown mode if active
                sacredEventsCountdownIntervalId = setInterval(() => {
                    eventsToToogleDisplay.forEach(event => {
                        const uniqueId = `sacred-event-time-${event.key}`;
                        const span = document.getElementById(uniqueId);
                        if (span) {
                            const now = new Date();
                            const diffMs = event.date.getTime() - now.getTime();
                            span.textContent = formatDuration(diffMs);
                        }
                    });
                }, 1000);
            }
        }

        // --- Sacred Event Adjustment Modal Logic (NEW) ---
        function openSacredEventAdjustmentModal() {
            sacredEventAdjustmentInputsContainer.innerHTML = ''; // Clear previous inputs
            sacredEventAdjustmentErrorMessageEl.classList.add('hidden'); // Hide any previous error messages
            HIJRI_SACRED_EVENTS.forEach(event => {
                const adjustmentValue = customSacredEventAdjustments[event.key] !== undefined ? customSacredEventAdjustments[event.key] : 0;
                const inputRow = document.createElement('div');
                inputRow.className = 'adjustment-input-row';
                inputRow.innerHTML = `
                    <label for="sacred-adj-${event.key}">${event.nameBg}:</label>
                    <input type="number" id="sacred-adj-${event.key}" data-event-key="${event.key}" value="${adjustmentValue}" class="shadow appearance-none border rounded-lg py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-600 border-gray-500 text-white" placeholder="–ù–∞–ø—Ä. 5 –∏–ª–∏ -3">
                `;
                sacredEventAdjustmentInputsContainer.appendChild(inputRow);
            });
            sacredEventAdjustmentModal.classList.remove('hidden');
        }

        function closeSacredEventAdjustmentModal() {
            sacredEventAdjustmentModal.classList.add('hidden');
            sacredEventAdjustmentErrorMessageEl.classList.add('hidden'); // Clear error message when closing modal
        }

        async function saveSacredEventAdjustments() {
            let changesMade = false;
            let hasInvalidInput = false;
            sacredEventAdjustmentErrorMessageEl.classList.add('hidden'); // Clear previous errors
            HIJRI_SACRED_EVENTS.forEach(event => {
                const inputElement = document.getElementById(`sacred-adj-${event.key}`);
                if (inputElement) {
                    const newOffset = parseInt(inputElement.value, 10);
                    if (isNaN(newOffset)) {
                        sacredEventAdjustmentErrorMessageEl.textContent = `–ù–µ–≤–∞–ª–∏–¥–Ω–æ —á–∏—Å–ª–æ –∑–∞ –∫–æ—Ä–µ–∫—Ü–∏—è –Ω–∞ ${event.nameBg}. –ú–æ–ª—è, –≤—ä–≤–µ–¥–µ—Ç–µ –≤–∞–ª–∏–¥–Ω–æ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä. 5 –∏–ª–∏ -3).`;
                        sacredEventAdjustmentErrorMessageEl.classList.remove('hidden');
                        hasInvalidInput = true;
                        return; 
                    }
                    if (customSacredEventAdjustments[event.key] !== newOffset) {
                        customSacredEventAdjustments[event.key] = newOffset;
                        changesMade = true;
                    }
                }
            });

            if (!hasInvalidInput) {
                if (changesMade) {
                    saveSettings(); // Save the new sacred event adjustments
                    // Re-populate the sacred events list to apply the new adjustments
                    await populateSacredEventsList(sacredEventsModalYear);
                }
                closeSacredEventAdjustmentModal();
            }
        }


        // --- Local Storage Functions ---
        function saveSettings() {
            const settingsToSave = {
                selectedCity: selectedCity,
                customPrayerAdjustments: customPrayerAdjustments,
                isClassicalNamesActive: isClassicalNamesActive,
                isSacredEventsCountdownMode: isSacredEventsCountdownMode, // Save this setting
                customSacredEventAdjustments: customSacredEventAdjustments // Save new sacred event adjustments
            };
            try {
                localStorage.setItem('prayerApp_settings', JSON.stringify(settingsToSave));
                // Optionally provide user feedback:
                // console.log("–ù–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –∑–∞–ø–∞–∑–µ–Ω–∏ —É—Å–ø–µ—à–Ω–æ!");
            } catch (e) {
                console.error("–ù–µ—É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∞–∑–≤–∞–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –≤ localStorage:", e);
                errorMessageEl.textContent = '–ù–µ—É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∞–∑–≤–∞–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ.';
                errorMessageEl.classList.remove('hidden');
            }
        }

        function loadSettings() {
            try {
                const savedSettings = JSON.parse(localStorage.getItem('prayerApp_settings'));
                if (savedSettings) {
                    selectedCity = savedSettings.selectedCity || "–°–æ—Ñ–∏—è";
                    customPrayerAdjustments = savedSettings.customPrayerAdjustments || {};
                    isClassicalNamesActive = savedSettings.isClassicalNamesActive || false;
                    isSacredEventsCountdownMode = savedSettings.isSacredEventsCountdownMode || false; // Load this setting
                    customSacredEventAdjustments = savedSettings.customSacredEventAdjustments || {}; // Load new sacred event adjustments
                    
                    // Update city display element
                    selectedCityDisplay.textContent = selectedCity;
                }
                // Always set selectedDate to today on load
                selectedDate = new Date(); 
                // Update the hidden input element so the date picker reflects today's date
                hiddenDateInput.value = formatDateForInputAndLookup(selectedDate);
            }
            catch (e) {
                console.error("–ù–µ—É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ –æ—Ç localStorage:", e);
                errorMessageEl.textContent = '–í—ä–∑–Ω–∏–∫–Ω–∞ –ø—Ä–æ–±–ª–µ–º –ø—Ä–∏ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏—Ç–µ. –ò–∑–ø–æ–ª–∑–≤–∞—Ç —Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ.';
                errorMessageEl.classList.remove('hidden');
                // Optionally clear corrupted settings if needed: localStorage.removeItem('prayerApp_settings');
            }
        }

        // Initial setup and periodic updates
        window.onload = function() {
            loadSettings(); // Load settings first
            
            updateClock(); // Start current time display
            fetchPrayerTimes(); // Initial fetch of prayer times using loaded settings

            // Event listener for Location button to open city selection modal
            locationSelectBtn.addEventListener('click', openCitySelectionModal);
            
            // Fixed event listener for closing city modal using the close button
            closeCityModalBtn.addEventListener('click', closeCitySelectionModal);

            // Event listener for closing city modal by clicking on the overlay
            citySelectionModal.addEventListener('click', (event) => {
                // Check if the click occurred directly on the modal-overlay (not its content)
                if (event.target === citySelectionModal) {
                    closeCitySelectionModal();
                }
            });

            // Event listener for the NEW countdown toggle button
            countdownToggleButton.addEventListener('click', () => {
                isCountdownMode = !isCountdownMode;
                // No need to save isCountdownMode to localStorage if it's meant to reset on page load.
                // If persistence is desired, uncomment the line below:
                // saveSettings(); 
                displayPrayerTimes(); // Re-display prayer times with the new mode
            });

            // Event listener for the new date picker button to trigger the hidden input
            datePickerBtn.addEventListener('click', () => {
                hiddenDateInput.showPicker(); // Opens the native date picker
            });

            // Event listener for hidden date input change
            hiddenDateInput.addEventListener('change', (event) => {
                selectedDate = new Date(event.target.value);
                fetchPrayerTimes(); // Re-fetch times for the newly selected date
            });

            // Event listener for the language toggle button
            languageToggleBtn.addEventListener('click', () => {
                isClassicalNamesActive = !isClassicalNamesActive;
                saveSettings(); // Automatically save language preference
                fetchPrayerTimes(); // Re-fetch/re-display to apply new names
            });
            
            // Event listeners for the global adjustment modal
            openAdjustmentModalBtn.addEventListener('click', openAdjustmentModal);
            cancelAdjustmentBtn.addEventListener('click', closeAdjustmentModal);
            saveAllAdjustmentsBtn.addEventListener('click', saveAllAdjustments); 

            // Event listener for the new "Return to Today" button
            returnTodayBtn.addEventListener('click', returnToToday);

            // --- New Sacred Events Modal Event Listeners ---
            openSacredEventsModalBtn.addEventListener('click', openSacredEventsModal);
            closeSacredEventsModalBtn.addEventListener('click', closeSacredEventsModal);
            sacredEventsModal.addEventListener('click', (event) => {
                if (event.target === sacredEventsModal) {
                    closeSacredEventsModal();
                }
            });

            prevSacredYearBtn.addEventListener('click', async () => {
                sacredEventsModalYear--;
                await populateSacredEventsList(sacredEventsModalYear);
            });

            nextSacredYearBtn.addEventListener('click', async () => {
                sacredEventsModalYear++;
                await populateSacredEventsList(sacredEventsModalYear);
            });

            toggleSacredEventsCountdownBtn.addEventListener('click', () => {
                isSacredEventsCountdownMode = !isSacredEventsCountdownMode;
                saveSettings(); // Save this preference
                renderSacredEventsListDisplay(); // Re-render the list with the new mode
            });

            // --- New Sacred Event Adjustment Modal Event Listeners ---
            openSacredEventAdjustmentModalBtn.addEventListener('click', openSacredEventAdjustmentModal);
            cancelSacredEventAdjustmentBtn.addEventListener('click', closeSacredEventAdjustmentModal);
            saveSacredEventAdjustmentsBtn.addEventListener('click', saveSacredEventAdjustments);


            // Update clock every second
            setInterval(updateClock, 1000);
            // Update main countdown every second (only active for today's date or specific logic for future/past)
            setInterval(updateCountdown, 1000);
        };
    </script>
</body>
</html>
