<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Времена за Намаз</title>
    <!-- Икона за уебсайт (favicon) актуализирана, за да препраща към статичен файл за по-добра съвместимост на хостинг платформи като GitHub Pages. -->
    <!-- Моля, уверете се, че имате файл 'favicon.png' в основната директория на вашия проект. -->
    <link rel="icon" href="/favicon.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Тъмен фон */
            color: #e2e8f0; /* Светъл цвят на текста */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Изравнява съдържанието в горната част */
            height: auto; /* Височината се определя от съдържанието */
            min-height: 100vh; /* Минимална височина на екрана */
            margin: 0;
            padding: 0.5rem; /* Възстановен padding на body */
            box-sizing: border-box;
            overflow-x: hidden; /* Предотвратява хоризонтално превъртане на цялото тяло */
            touch-action: pan-y; /* Позволява вертикално превъртане, но указва хоризонталното да се обработва от JS */
        }

        /* Обвиващ елемент за цялото приложение, позволяващ "избутване" на менюто */
        #app-wrapper {
            display: flex;
            width: 100%;
            height: auto; /* Височината се определя от съдържанието */
            position: relative;
            box-sizing: border-box;
            /* Предотвратява хоризонтално превъртане, ако основното съдържание е избутано извън екрана */
            overflow: hidden; /* Скрий всяко преливане от вътрешни елементи, включително при трансформации */
        }

        /* Контейнер за основното съдържание на приложението */
        #main-content-wrapper {
            flex-grow: 1; /* Заема цялото останало пространство */
            width: 100%; /* Запълва наличната хоризонтална ширина */
            transition: transform 0.3s ease-out; /* Плавен преход за избутване */
            transform: translateX(0); /* Начално състояние: не е избутан */
            padding: 0; /* Премахнат padding от wrapper, управлява се от container */
            box-sizing: border-box;
            display: flex; /* За да може хамбургер бутонът да се позиционира */
            flex-direction: column; /* За да може съдържанието вътре да е подредено */
            align-items: center; /* Центрира контейнера */
        }

        .container {
            background-color: #2d3748; /* Леко по-тъмен фон за картата */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 1.5rem; /* По-заоблени ъгли */
            padding: 1rem; /* Намален padding на контейнера */
            width: 100%;
            max-width: 480px; /* Максимална ширина по подразбиране за мобилни устройства */
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Намалена празнина за по-добро прилягане */
            box-sizing: border-box;
            height: auto; /* Височината се определя от съдържанието */
        }
        /* Адаптивна максимална ширина за по-големи екрани */
        @media (min-width: 768px) { /* md breakpoint */
            .container {
                max-width: 640px; /* md:max-w-xl */
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            .container {
                max-width: 768px; /* lg:max-w-2xl */
            }
        }

        /* Адаптивни размери на текста за обратно броене */
        #countdown {
            font-weight: 700;
            color: #a0aec0; /* По-светло сиво за време */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .countdown-text {
            font-size: 1.1rem; /* Леко по-малък за по-плътно прилягане */
            font-weight: 500;
            color: #cbd5e0;
            margin-top: 0.25rem; /* Намален margin */
        }
        .prayer-row {
            display: flex;
            justify-content: space-between; /* Държи името вляво, а времето/бутона вдясно */
            align-items: center;
            padding: 0.5rem 0; /* Намален padding */
            border-bottom: 1px solid #4a5568; /* Деликатен разделител */
        }
        .prayer-row:last-child {
            border-bottom: none;
        }
        .prayer-name {
            font-size: 1rem; /* Леко по-малък */
            font-weight: 500;
            color: #cbd5e0;
        }
        .prayer-time {
            font-size: 1.1rem; /* Леко по-малък */
            font-weight: 600;
            color: #a0aec0;
        }
        .highlighted-prayer .prayer-name,
        .highlighted-prayer .prayer-time {
            color: #68d391; /* Цвят за подчертаване */
            font-weight: 700;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #68d391;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Общ стил на бутоните за действия (дата, език, корекции) */
        .action-button {
            background-color: #4a5568;
            color: #e2e8f0;
            border: 1px solid #68d391;
            border-radius: 0.5rem;
            padding: 0.5rem; /* По-малък padding за бутон само с емотикони */
            width: 3rem; /* Фиксирана ширина за бутон с емотикони */
            height: 3rem; /* Фиксирана височина за бутон с емотикони */
            font-size: 1.5rem; /* По-голям емотикон */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            white-space: nowrap; /* Предотвратява пренасяне на текст за текстови бутони */
        }
        .action-button:hover {
            background-color: #5a677d;
        }
        .action-button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(104, 211, 145, 0.5);
        }

        /* Стилове за бутона на хамбургер менюто */
        #hamburger-menu-btn {
            position: fixed; /* Позиционира се спрямо viewport-а */
            top: 1rem;
            left: 1rem;
            z-index: 101; /* Уверете се, че е над всичко останало */
        }

        /* Стилове за страничното меню */
        .side-menu {
            position: absolute; /* Позициониран спрямо app-wrapper */
            top: 0;
            left: 0;
            height: 100vh; /* Цяла височина на изгледа */
            width: 280px; /* Ширина на менюто */
            background-color: #2d3748; /* Същият като контейнера или малко по-тъмен */
            z-index: 100; /* По-висок от основното съдържание */
            transform: translateX(-100%); /* Първоначално скрит извън екрана */
            transition: transform 0.3s ease-out; /* Плавен преход на плъзгане */
            padding: 1.5rem;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5); /* Сянка за дълбочина */
            display: flex;
            flex-direction: column;
            gap: 1rem; /* Разстояние между елементите на менюто */
            box-sizing: border-box;
            overflow-y: auto; /* Позволява превъртане, ако съдържанието на менюто е твърде дълго */
        }
        .side-menu.open {
            transform: translateX(0); /* Плъзга се във видимост */
        }

        /* Премахнат overlay, тъй като менюто вече "избутва" съдържанието */
        #menu-overlay {
            display: none !important; /* Уверете се, че е напълно скрит */
        }
        
        /* Корекции за бутоните вътре в менюто, за да пасват на новото оформление текст + емотикон */
        .side-menu .action-button {
            width: 100%; /* Правят се на цяла ширина в менюто */
            justify-content: flex-start; /* Подравнява текста в началото */
            padding: 0.75rem 1rem; /* По-голям padding за по-добри зони за докосване */
            font-size: 1rem; /* По-малък шрифт за текстови бутони */
            height: auto; /* Автоматична височина за текстови бутони */
            gap: 0.75rem; /* Разстояние между емотикон и текст */
        }
        .side-menu .action-button > span { /* За емотиконите в текстовите бутони */
            font-size: 1.5rem; /* Запазва размера на емотикона постоянен */
        }

        /* Бутон за затваряне в менюто */
        #close-side-menu-btn {
            background: none;
            border: none;
            color: #e2e8f0;
            font-size: 2rem;
            padding: 0;
            cursor: pointer;
            align-self: flex-end; /* Подравнява се вдясно в гъвкавата колона */
            margin-bottom: 1rem;
            width: auto; /* Не насилва фиксирана ширина */
            height: auto; /* Не насилва фиксирана височина */
        }
        #close-side-menu-btn:hover {
            color: #68d391;
            background-color: transparent; /* Без фон при hover */
        }

        /* Скрит инпут за избор на дата - наистина скрит */
        #hidden-date-input {
            display: none; 
        }

        /* Стилове на модалните прозорци (запазени същите, но по-висок z-index за модалите, свързани с хамбургер менюто) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 110; /* По-висок от страничното меню и неговия overlay */
            padding: 0.5rem;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #2d3748;
            border-radius: 1.5rem;
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            color: #e2e8f0;
            max-height: 95vh;
            overflow-y: auto;
        }
        .city-list-item {
            padding: 0.6rem 1rem;
            border-bottom: 1px solid #4a5568;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }
        .city-list-item:hover {
            background-color: #3a475d;
        }
        .city-list-item.selected {
            background-color: #68d391;
            color: #1a202c;
            font-weight: 600;
        }
        .city-list-item:last-child {
            border-bottom: none;
        }

        .adjustment-input-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .adjustment-input-row label {
            font-size: 1rem;
            font-weight: 500;
            color: #cbd5e0;
        }
        .adjustment-input-row input[type="number"] {
            width: 70px;
            text-align: center;
            background-color: #4a5568;
            border: 1px solid #68d391;
            color: #e2e8f0;
            border-radius: 0.375rem;
            padding: 0.25rem 0.4rem;
        }
    </style>
</head>
<body class="antialiased">
    <!-- Обвиващ елемент за цялото приложение -->
    <div id="app-wrapper"> 
        <!-- Странично меню -->
        <div id="side-menu" class="side-menu">
            <button id="close-side-menu-btn" class="action-button">✖</button>
            
            <button id="location-select-btn" class="action-button">
                <span>📍</span> Изберете град
            </button>
            <button id="countdown-toggle-btn" class="action-button">
                <span>⌛</span> Режим Отброяване
            </button>
            <div class="relative w-full">
                <button id="date-picker-btn" class="action-button">
                    <span>🗓️</span> Изберете Дата
                </button>
                <input type="date" id="hidden-date-input">
            </div>
            <button id="language-toggle-btn" class="action-button">
                <span>💬</span> Смени Езика
            </button>
            <button id="open-adjustment-modal-btn" class="action-button">
                <span>⚙️</span> Корекции
            </button>
        </div>

        <!-- Основен контейнер за съдържанието, който ще бъде избутван -->
        <div id="main-content-wrapper">
            <!-- Хамбургер бутон - вече е фиксиран, за да стои извън основния блок -->
            <button id="hamburger-menu-btn" class="action-button">☰</button>

            <div class="container">
                <!-- Горен ред: Грегорианска дата и ден + текущо време (ляво), Хиджра дата и свещен ден + местоположение (дясно) -->
                <div class="flex justify-between items-start text-sm md:text-base">
                    <div id="gregorian-date-info" class="flex flex-col items-start font-medium text-gray-400">
                        <span id="current-date"></span>
                        <span id="current-day"></span>
                        <div id="current-time" class="text-lg font-semibold text-gray-300 mt-1"></div>
                    </div>
                    <div id="hijri-and-sacred-info" class="flex flex-col items-end text-gray-500">
                        <span id="hijri-date"></span>
                        <span id="sacred-day-info" class="text-green-400 font-semibold text-xs mt-1"></span>
                        <span id="selected-city-display" class="text-gray-400 text-sm mt-1">София</span>
                    </div>
                </div>

                <div class="text-center flex flex-col items-center">
                    <div class="flex items-center justify-center gap-2 mb-1">
                        <div id="countdown" class="text-4xl md:text-5xl lg:text-6xl font-bold text-gray-400">--:--:--</div>
                        <button id="return-today-btn" class="action-button !w-10 !h-10 !text-xl hidden">🔄</button>
                    </div>
                    <div id="countdown-text" class="countdown-text">зареждане...</div>
                </div>
                
                <!-- Индикатор за зареждане -->
                <div id="loading-indicator" class="flex justify-center items-center py-4 hidden">
                    <div class="loading-spinner"></div>
                </div>

                <div id="prayer-times-list" class="flex flex-col gap-1">
                    <!-- Времената за намаз ще бъдат попълнени тук -->
                </div>

                <div id="error-message" class="hidden text-center text-red-400 text-sm mt-2">
                    Възникна грешка при зареждане на времената за намаз. Моля, опитайте отново по-късно.
                </div>

                <!-- Долният ред с бутони за действие е премахнат, тъй като са в хамбургер менюто -->
            </div>
        </div>
    </div>

    <!-- Модален прозорец за избор на град -->
    <div id="city-selection-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-white mb-4">Изберете град</h3>
            <div id="city-list" class="flex flex-col gap-1 mb-4">
                <!-- Опциите за град ще бъдат попълнени тук от JavaScript -->
            </div>
            <div class="flex justify-end">
                <button id="close-city-modal-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">Затвори</button>
            </div>
        </div>
    </div>

    <!-- Глобален модален прозорец за корекции на намази (преработен) -->
    <div id="adjustment-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-semibold text-white mb-4">Корекции на времена за намаз</h3>
            <p class="text-gray-300 text-sm mb-3">Въведете корекция в минути (+ за напред, - за назад):</p>
            <div id="prayer-adjustment-inputs" class="mb-4">
                <!-- Входовете за корекции ще бъдат генерирани динамично тук -->
            </div>
            <div class="flex justify-end space-x-3">
                <button id="cancel-adjustment-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">Отказ</button>
                <button id="save-all-adjustments-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-xl focus:outline-none focus:shadow-outline transition duration-150 ease-in-out">Запази</button>
            </div>
        </div>
    </div>

    <script>
        // --- ДАННИ ЗА СВЕЩЕНИ ДНИ (ПРИМЕР) ---
        // Това е твърдо кодиран примерен списък със свещени дни за демонстрация.
        // За цялостно решение тези данни биха били предварително генерирани за много години.
        // Данни, извлечени от календара на Диянет за религиозни дни (подлежат на официална проверка).
        const sacredDays = {
            // 2024 (Запазени както са, вероятно са верни или достатъчно близки за 2024 г.)
            "2024-01-11": "Нощта на Регаиб",
            "2024-02-06": "Нощта на Мирадж",
            "2024-02-24": "Нощта на Берат",
            "2024-03-11": "Начало на Рамазан",
            "2024-04-05": "Нощта Кадир",
            "2024-04-10": "Рамазан Байрам - Ден 1",
            "2024-04-11": "Рамазан Байрам - Ден 2",
            "2024-04-12": "Рамазан Байрам - Ден 3",
            "2024-06-15": "Денят Арафа",
            "2024-06-16": "Курбан Байрам - Ден 1",
            "2024-06-17": "Курбан Байрам - Ден 2",
            "2024-06-18": "Курбан Байрам - Ден 3",
            "2024-06-19": "Курбан Байрам - Ден 4",
            "2024-07-07": "Нова Хиджri година (1446 г. по Хиджра)",
            "2024-07-16": "Ашура",
            "2024-09-14": "Мевлид Кандилли",

            // 2025 (Актуализирани въз основа на календара на Диянет за 2025 г. и конкретна заявка на потребителя за Курбан Байрам)
            "2025-01-30": "Нощта на Регаиб",
            "2025-02-26": "Нощта на Мирадж",
            "2025-03-15": "Нощта на Берат",
            "2025-03-01": "Начало на Рамазан", 
            "2025-03-26": "Нощта Кадир",      
            "2025-03-31": "Рамазан Байрам - Ден 1", 
            "2025-04-01": "Рамазан Байрам - Ден 2", 
            "2025-04-02": "Рамазан Байрам - Ден 3", 
            "2025-06-05": "Денят Арафа",        
            "2025-06-06": "Курбан Байрам - Ден 1", 
            "2025-06-07": "Курбан Байрам - Ден 2", 
            "2025-06-08": "Курбан Байрам - Ден 3", 
            "2025-06-09": "Курбан Байрам - Ден 4", 
            "2025-06-26": "Нова Хиджri година (1447 г. по Хиджра)", 
            "2025-07-05": "Ашура",              
            "2025-08-26": "Мевлид Кандилли"     
        };
        // --- КРАЙ НА ДАННИТЕ ЗА СВЕЩЕНИ ДНИ ---


        // DOM Елементи
        const currentTimeEl = document.getElementById('current-time');
        const countdownEl = document.getElementById('countdown');
        const countdownTextEl = document.getElementById('countdown-text');
        const currentDateEl = document.getElementById('current-date');
        const currentDayEl = document.getElementById('current-day');
        const hijriDateEl = document.getElementById('hijri-date');
        const sacredDayInfoEl = document.getElementById('sacred-day-info'); 
        const prayerTimesListEl = document.getElementById('prayer-times-list');
        const loadingIndicatorEl = document.getElementById('loading-indicator');
        const errorMessageEl = document.getElementById('error-message');
        const selectedCityDisplay = document.getElementById('selected-city-display'); 
        const hiddenDateInput = document.getElementById('hidden-date-input'); 
        const returnTodayBtn = document.getElementById('return-today-btn'); // Нов бутон

        // Нови DOM Елементи за Хамбургер менюто
        const hamburgerMenuBtn = document.getElementById('hamburger-menu-btn');
        const sideMenu = document.getElementById('side-menu');
        const closeSideMenuBtn = document.getElementById('close-side-menu-btn');
        const mainContentWrapper = document.getElementById('main-content-wrapper'); // Нова обвивка за основното съдържание

        // Препратки към бутони, които вече са вътре в страничното меню
        const locationSelectBtn = document.getElementById('location-select-btn');
        const countdownToggleButton = document.getElementById('countdown-toggle-btn');
        const datePickerBtn = document.getElementById('date-picker-btn');
        const languageToggleBtn = document.getElementById('language-toggle-btn');
        const openAdjustmentModalBtn = document.getElementById('open-adjustment-modal-btn');


        // Модали и техните елементи
        const citySelectionModal = document.getElementById('city-selection-modal'); 
        const cityListEl = document.getElementById('city-list');
        const closeCityModalBtn = document.getElementById('close-city-modal-btn');

        const adjustmentModal = document.getElementById('adjustment-modal');
        const prayerAdjustmentInputsContainer = document.getElementById('prayer-adjustment-inputs'); 
        const cancelAdjustmentBtn = document.getElementById('cancel-adjustment-btn');
        const saveAllAdjustmentsBtn = document.getElementById('save-all-adjustments-btn'); 

        // Имена на намази на български (Обедна ще се обработва условно)
        const prayerNamesStandard = {
            Fajr: 'Зора',
            Sunrise: 'Изгрев',
            Dhuhr: 'Обедна', 
            Asr: 'Следобедна',
            Maghrib: 'Вечерна',
            Isha: 'Нощна'
        };

        const prayerNamesClassical = {
            Fajr: 'Заговеване', 
            Sunrise: 'Изгиране', 
            Dhuhr: 'Пладен', 
            Asr: 'Икиндие', 
            Maghrib: 'Ашем', 
            Isha: 'Йецие' 
        };

        // Всички ключове на намази за итерация
        const allPrayerKeys = ['Fajr', 'Sunrise', 'Dhuhr', 'Asr', 'Maghrib', 'Isha'];

        // Общи корекции, специфични за намаз, в минути (прилагат се върху основните времена)
        const adjustments = {
            Fajr: 0,
            Sunrise: -7,
            Dhuhr: 5,
            Asr: 4,
            Maghrib: 6,
            Isha: 0 
        };

        // Персонализирани градски отмествания спрямо София (минути за добавяне/изваждане от времената на София)
        // Тези отмествания вече ще се прилагат към времената, извлечени от API за София.
        const cityOffsets = {
            "София": 0, // Базов град, без отместване
            "Гоце Делчев": -1,
            "Якоруда": -1,
            "Велинград": -3,
            "Кнежа": -3,
            "Ловеч": -5,
            "Смолян": -5,
            "Пловдив": -5,
            "Плевен": -5,
            "Мадан": -6,
            "Никопол": -6,
            "Карлово": -6,
            "Свищов": -8,
            "Кърджали": -8,
            "Крумовград": -9,
            "Велико Търново": -9,
            "Стара Загора": -9,
            "Хасково": -9,
            "Горна Оряховица": -9,
            "Русе": -10,
            "Твърдица": -10,
            "Харманли": -10,
            "Нова Загора": -10,
            "Кубрат": -12,
            "Разград": -12,
            "Котел": -12,
            "Сливен": -12,
            "Ямбол": -12,
            "Исперих": -13,
            "Велики Преслав": -13,
            "Търговище": -13,
            "Ситово": -14,
            "Каолиново": -14,
            "Карнобат": -14,
            "Шумен": -14,
            "Нови Пазар": -15,
            "Айтос": -15,
            "Провадия": -16,
            "Бургас": -16,
            "Силистра": -16,
            "Добрич": -17,
            "Бяла": -17,
            "Балчик": -18,
            "Варна": -18,
            "Каварна": -19
        };

        // Картиране на имената на хиджра месеците към български
        const hijriMonthsBg = {
            "Muharram": "Мухаррем",
            "Safar": "Сафер",
            "Rabi' al-Awwal": "Рабиюлеввел",
            "Rabi' al-Thani": "Рабиюлахир",
            "Jumada al-Awwal": "Джемазиюлеввел",
            "Jumada al-Thani": "Джемазиюлахир",
            "Rajab": "Реджеб",
            "Sha'ban": "Шабан",
            "Ramadan": "Рамазан",
            "Shawwal": "Шеввал",
            "Dhul-Qadah": "Зилкаде",
            "Dhul-Hijjah": "Зилхидже"
        };

        let prayerTimes = {}; // Съхранява извлечените времена за намаз (след всички корекции за избрания град)
        let nextPrayerIndex = -1; // Индекс на следващия намаз в списъка
        let selectedCity = "София"; // Град по подразбиране
        let currentHijriDate = ''; // За съхраняване и показване на хиджра дата
        let selectedDate = new Date(); // Съхранява текущо избраната дата (по подразбиране е днес)
        let customPrayerAdjustments = {}; // Съхранява дефинирани от потребителя корекции за всеки намаз {Fajr: 5, Dhuhr: -2}
        let isClassicalNamesActive = false; // Състояние за конвенцията за именуване
        let isCountdownMode = false; // Състояние за режим на обратно броене в списъка с намази

        // Глобална променлива за интервала за обратно броене на отделните намази
        let individualCountdownIntervalId = null;
        // Глобален масив за съхраняване на данни за намази с обекти Date за динамични актуализации
        let prayersDataForDisplay = []; 

        // Вземане на текущите имена на намази въз основа на състоянието
        function getCurrentPrayerNames() {
            return isClassicalNamesActive ? prayerNamesClassical : prayerNamesStandard;
        }

        // Попълване на списъка с градове в модалния прозорец
        function populateCityList() {
            cityListEl.innerHTML = ''; // Изчиства предишния списък
            const sortedCities = Object.keys(cityOffsets).sort((a, b) => {
                if (a === "София") return -1;
                if (b === "София") return 1;
                return a.localeCompare(b);
            });

            sortedCities.forEach(city => {
                const cityItem = document.createElement('div');
                cityItem.className = 'city-list-item';
                if (city === selectedCity) {
                    cityItem.classList.add('selected');
                }
                cityItem.textContent = city;
                cityItem.dataset.city = city;
                cityItem.addEventListener('click', () => {
                    selectedCity = city;
                    selectedCityDisplay.textContent = selectedCity; // Актуализиране на текста за показване на избрания град
                    closeCitySelectionModal();
                    closeSideMenu(); // Затваряне на страничното меню след избор на град
                    fetchPrayerTimes(); // Извличане на времената за новия град
                    saveSettings(); // Автоматично запазване на промяната на града
                });
                cityListEl.appendChild(cityItem);
            });
        }

        // Функция за форматиране на времето до HH:MM
        function formatTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // Функция за форматиране на продължителността (за режим на обратно броене в списъка)
        function formatDuration(milliseconds) {
            let prefix = '';
            if (milliseconds < 0) {
                prefix = '-';
                milliseconds = Math.abs(milliseconds); // Използвайте абсолютна стойност за изчисление
            }

            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            let timeParts = [];
            
            // Винаги включвайте часове, минути и секунди, допълнени с две цифри.
            timeParts.push(`${String(hours).padStart(2, '0')}ч`);
            timeParts.push(`${String(minutes).padStart(2, '0')}м`);
            timeParts.push(`${String(seconds).padStart(2, '0')}с`);

            let timeDisplay = timeParts.join(' ');
            
            return prefix + timeDisplay.trim(); 
        }


        // Функция за форматиране на датата до ДД.ММ.ГГГГ
        function formatDate(date) {
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Месецът е базиран на 0
            const year = date.getFullYear();
            return `${day}.${month}.${year}`;
        }

        // Функция за форматиране на датата до ГГГГ-ММ-ДД за input type="date" и API повиквания
        function formatDateForInputAndLookup(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Функция за извличане на името на деня от седмицата на български
        function getDayNameBg(date) {
            const days = ['Неделя', 'Понеделник', 'Вторник', 'Сряда', 'Четвъртък', 'Петък', 'Събота'];
            return days[date.getDay()];
        }

        // Функция за определяне на името на Обедна (Dhuhr) въз основа на деня от седмицата и текущия стил на именуване
        function getDhuhrName(date) {
            if (date.getDay() === 5) { // Петък
                return isClassicalNamesActive ? "Джумайо" : "Джума"; 
            }
            return isClassicalNamesActive ? "Пладен" : "Обедна";
        }

        // Функция за актуализиране на дисплея на текущото време
        function updateClock() {
            const now = new Date();
            currentTimeEl.textContent = formatTime(now);
        }

        // Функция за извличане на времената за намаз от API
        async function fetchPrayerTimes() {
            // Показване на индикатор за зареждане
            loadingIndicatorEl.classList.remove('hidden');
            errorMessageEl.classList.add('hidden'); 
            prayerTimesListEl.innerHTML = ''; // Изчиства предишните времена

            // Изчистване на всички текущи индивидуални обратно броене преди извличане на нови данни
            clearInterval(individualCountdownIntervalId);
            individualCountdownIntervalId = null;

            const currentDateStringForAPI = `${String(selectedDate.getDate()).padStart(2, '0')}-${String(selectedDate.getMonth() + 1).padStart(2, '0')}-${selectedDate.getFullYear()}`;

            // Актуализиране на дисплея за грегорианска дата и ден
            currentDateEl.textContent = formatDate(selectedDate);
            currentDayEl.textContent = getDayNameBg(selectedDate);
            selectedCityDisplay.textContent = selectedCity; // Актуализиране на текста за показване на избрания град

            // Извличане на базовите времена за София с помощта на метода на Диянет (method=10)
            const diyanetApiUrl = `https://api.aladhan.com/v1/timingsByCity/${currentDateStringForAPI}?city=Sofia&country=Bulgaria&method=10`;
            
            // Извличане на времето за Нощна (Isha) конкретно с помощта на метода на Мюсюлманската световна лига (method=3)
            const mwlIshaApiUrl = `https://api.aladhan.com/v1/timingsByCity/${currentDateStringForAPI}?city=Sofia&country=Bulgaria&method=3`;

            try {
                const [diyanetResponse, mwlIshaResponse] = await Promise.all([
                    fetch(diyanetApiUrl),
                    fetch(mwlIshaApiUrl)
                ]);

                if (!diyanetResponse.ok || !mwlIshaResponse.ok) {
                    throw new Error(`HTTP грешка! Статуси: Диянет ${diyanetResponse.status}, MWL ${mwlIshaResponse.status}`);
                }

                const diyanetData = await diyanetResponse.json();
                const mwlIshaData = await mwlIshaResponse.json();

                // Проверка за основни данни за изчисление на времената за намаз
                if (!diyanetData.data || !diyanetData.data.timings || !mwlIshaData.data || !mwlIshaData.data.timings) {
                    throw new Error('Невалиден отговор от API или липсващи основни данни за времена за намаз.');
                }

                // Продължете с изчисляването на времената за намаз
                const sofiaBaseTimings = {
                    Fajr: diyanetData.data.timings.Fajr,
                    Sunrise: diyanetData.data.timings.Sunrise,
                    Dhuhr: diyanetData.data.timings.Dhuhr,
                    Asr: diyanetData.data.timings.Asr,
                    Maghrib: diyanetData.data.timings.Maghrib,
                    Isha: mwlIshaData.data.timings.Isha // Заменяне на Isha с времето на MWL
                };

                const currentCityCustomOffset = cityOffsets[selectedCity] || 0;
                const adjustedPrayerTimes = {};

                // Прилагане на общи и градски отмествания към извлечените от API времена за София
                for (const key of allPrayerKeys) { // Итериране през всички ключове на намази за последователен ред
                    if (sofiaBaseTimings.hasOwnProperty(key)) {
                        let [hour, minute] = sofiaBaseTimings[key].split(':').map(Number);
                        let tempDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), selectedDate.getDate(), hour, minute, 0);

                        // Прилагане на обща корекция, специфична за намаз
                        if (adjustments[key] !== undefined) { 
                            tempDate.setMinutes(tempDate.getMinutes() + adjustments[key]);
                        }
                        // Прилагане на персонализирано отместване, специфично за града
                        tempDate.setMinutes(tempDate.getMinutes() + currentCityCustomOffset);

                        // Прилагане на персонализирана корекция от потребителя (от локалното хранилище)
                        if (customPrayerAdjustments[key] !== undefined) {
                            tempDate.setMinutes(tempDate.getMinutes() + customPrayerAdjustments[key]);
                        }

                        adjustedPrayerTimes[key] = formatTime(tempDate);
                    }
                }
                
                prayerTimes = adjustedPrayerTimes; // Съхраняване на напълно коригираните времена

                // Обработка на хиджра датата отделно със собствени проверки за устойчивост
                if (diyanetData.data.date && diyanetData.data.date.hijri) {
                    const hijri = diyanetData.data.date.hijri;
                    if (hijri.day && hijri.month && hijri.month.en && hijri.year) {
                        const hijriDay = hijri.day;
                        const hijriMonthEnglish = hijri.month.en;
                        const hijriYear = hijri.year;
                        const hijriMonthBg = hijriMonthsBg[hijriMonthEnglish] || hijriMonthEnglish; 
                        currentHijriDate = `${hijriDay} ${hijriMonthBg} ${hijriYear} г.`; 
                        hijriDateEl.textContent = currentHijriDate;
                    } else {
                        console.warn("Данните за хиджра дата са непълни от отговора на API.");
                        currentHijriDate = 'Няма хиджри дата';
                        hijriDateEl.textContent = currentHijriDate;
                    }
                } else {
                    console.warn("Обектът за хиджра дата липсва от отговора на API.");
                    currentHijriDate = 'Няма хиджри дата';
                    hijriDateEl.textContent = currentHijriDate;
                }

                // Проверка и показване на свещения ден/нощ
                const sacredDayKey = formatDateForInputAndLookup(selectedDate);
                if (sacredDays[sacredDayKey]) {
                    sacredDayInfoEl.textContent = sacredDays[sacredDayKey]; 
                    sacredDayInfoEl.classList.remove('hidden');
                } else {
                    sacredDayInfoEl.textContent = '';
                    sacredDayInfoEl.classList.add('hidden');
                }

                displayPrayerTimes(); // Извикване на показване за рендиране и управление на обратното броене
                
            } catch (error) {
                console.error('Грешка при извличане на времената за намаз:', error);
                errorMessageEl.classList.remove('hidden');
                errorMessageEl.textContent = `Възникна грешка при зареждане на времената за намаз: ${error.message}. Моля, проверете връзката си и опитайте отново.`;
                prayerTimes = {};
                prayerTimesListEl.innerHTML = '';
                hijriDateEl.textContent = '';
                sacredDayInfoEl.textContent = '';
                sacredDayInfoEl.classList.add('hidden');
            } finally {
                // Скриване на индикатора за зареждане
                loadingIndicatorEl.classList.add('hidden');
            }
        }

        // Функция за показване на времената за намаз в списъка
        function displayPrayerTimes() {
            prayerTimesListEl.innerHTML = ''; // Изчиства предишните времена

            const now = new Date(); // Текущо време за първоначално сравнение
            const targetDate = selectedDate; 
            
            prayersDataForDisplay = []; // Изчистване и повторно попълване на глобалния масив

            const currentPrayerNames = getCurrentPrayerNames();

            for (const key of allPrayerKeys) { 
                if (prayerTimes.hasOwnProperty(key)) {
                    const [hour, minute] = prayerTimes[key].split(':').map(Number);
                    let prayerDate = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), hour, minute, 0);

                    let displayName = currentPrayerNames[key] || key;
                    if (key === 'Dhuhr') {
                        displayName = getDhuhrName(targetDate); 
                    }

                    prayersDataForDisplay.push({
                        name: key,
                        displayName: displayName,
                        staticTime: formatTime(prayerDate), // Съхраняване на статично форматирано време
                        date: prayerDate // Съхраняване на действителния обект Date за обратно броене
                    });
                }
            }

            // Сортиране на намазите по време за осигуряване на правилен ред
            prayersDataForDisplay.sort((a, b) => a.date.getTime() - b.date.getTime());

            // Използвайте отделна променлива за подчертаване
            let highlightIndex = -1; 

            if (selectedDate.toDateString() === new Date().toDateString()) {
                // Подчертавайте само ако е днешната дата
                for (let i = 0; i < prayersDataForDisplay.length; i++) {
                    if (prayersDataForDisplay[i].date > now) { 
                        highlightIndex = i; // Намерен е бъдещ намаз за текущия ден, който да бъде подчертан
                        break;
                    }
                }
                // Ако всички намази за днес са минали, highlightIndex ще остане -1,
                // което означава, че няма да бъде подчертан намаз, което е желаното поведение.
            } else {
                // За минали или бъдещи избрани дати не трябва да има подчертаване.
                highlightIndex = -1; 
            }

            // Рендиране на времената за намаз първоначално със статични времена
            prayersDataForDisplay.forEach((prayer, index) => {
                const prayerRow = document.createElement('div');
                prayerRow.className = 'prayer-row';

                // Прилагане на подчертаване въз основа на отделния highlightIndex
                if (index === highlightIndex) {
                    prayerRow.classList.add('highlighted-prayer');
                }

                // Рендиране със статично време. Динамичните актуализации ще го презапишат, ако режимът на обратно броене е активен.
                prayerRow.innerHTML = `
                    <span class="prayer-name">${prayer.displayName}</span>
                    <div class="flex items-center">
                        <span class="prayer-time" id="prayer-time-${prayer.name}">${prayer.staticTime}</span>
                    </div>
                `;
                prayerTimesListEl.appendChild(prayerRow);
            });

            startStopIndividualCountdowns(); // Управление на интервала за обратно броене на отделните намази
            updateCountdown(); // Актуализиране на основното обратно броене (до следващия намаз)
        }

        // Функция за стартиране или спиране на обратно броене на отделни намази в списъка
        function startStopIndividualCountdowns() {
            clearInterval(individualCountdownIntervalId); // Винаги изчиствайте всеки съществуващ интервал първо
            individualCountdownIntervalId = null;

            if (isCountdownMode && selectedDate.toDateString() === new Date().toDateString()) {
                // Ако е в режим на обратно броене И е днешна дата, стартирайте динамичните актуализации
                updateIndividualCountdowns(); // Извикайте веднъж незабавно, за да зададете първоначалното обратно броене
                individualCountdownIntervalId = setInterval(updateIndividualCountdowns, 1000);
            } else {
                // Ако не е в режим на обратно броене или не е днешна дата, уверете се, че се показват статични времена.
                // Този цикъл гарантира, че ако изключим режима на обратно броене, времената ще се върнат към статичните.
                prayersDataForDisplay.forEach(prayer => {
                    const span = document.getElementById(`prayer-time-${prayer.name}`);
                    if (span) {
                        span.textContent = prayer.staticTime; // Връщане към статично време
                    }
                });
            }
        }

        // Функция за динамично актуализиране на обратно броене на отделни намази в списъка
        function updateIndividualCountdowns() {
            // Тази функция се извиква само ако isCountdownMode е true и selectedDate е днешна дата
            const now = new Date();
            prayersDataForDisplay.forEach(prayer => {
                const span = document.getElementById(`prayer-time-${prayer.name}`);
                if (span) {
                    const diffMs = prayer.date.getTime() - now.getTime();
                    span.textContent = formatDuration(diffMs);
                }
            });
        }

        // Помощна функция за изчисляване на разликата в години, месеци и дни между две дати
        function getYearsMonthsDaysDifference(d1, d2) { // d1 = начална дата (сега), d2 = крайна дата (selectedDate)
            let years = d2.getFullYear() - d1.getFullYear();
            let months = d2.getMonth() - d1.getMonth();
            let days = d2.getDate() - d1.getDate();

            // Корекция за отрицателни дни (d2.getDate() < d1.getDate())
            if (days < 0) {
                months--;
                // Вземете броя дни в месеца *преди* месеца на d2 в годината на d2
                let daysInPrevMonthOfD2 = new Date(d2.getFullYear(), d2.getMonth(), 0).getDate();
                days += daysInPrevMonthOfD2;
            }

            // Корекция за отрицателни месеци (d2.getMonth() < d1.getMonth())
            if (months < 0) {
                years--;
                months += 12;
            }

            return { years, months, days };
        }

        // Функция за актуализиране на обратното броене до следващия намаз (основно обратно броене)
        function updateCountdown() {
            const now = new Date();

            if (selectedDate.toDateString() !== now.toDateString()) {
                // Обработка на бъдещи/минали избрани дати
                const diff = getYearsMonthsDaysDifference(now, selectedDate);
                let displayMessage = '';
                returnTodayBtn.classList.remove('hidden'); // Показване на бутона "Връщане към днес"

                if (selectedDate > now) { // Бъдеща дата
                    if (diff.years > 0) {
                        displayMessage += `след ${diff.years} г.`;
                        if (diff.months > 0) {
                            displayMessage += ` ${diff.months} м.`;
                        }
                    } else if (diff.months > 0) {
                        displayMessage += `след ${diff.months} м.`;
                        if (diff.days > 0) {
                            displayMessage += ` ${diff.days} дни`;
                        }
                    } else if (diff.days > 0) {
                        displayMessage += `след ${diff.days} дни`;
                    } else { // Много близко бъдеще, в рамките на същите дневни часове
                        // Този случай би трябвало да се обработи от логиката за "днешна дата", ако `selectedDate` е буквално днес.
                        // Ако е бъдеща дата, която е само на няколко часа/минути, но все още на *тази* конкретна дата,
                        // можем да покажем заместител или да преминем към логиката за "днес".
                        countdownEl.textContent = '--:--:--'; // Без обратно броене за концептуални бъдещи дати
                        countdownTextEl.textContent = 'Избрана е бъдеща дата.'; 
                        return; // Изход, тъй като това не е днешното обратно броене
                    }
                    countdownEl.textContent = '--:--:--'; // Без обратно броене за концептуални бъдещи дати
                    countdownTextEl.textContent = displayMessage || 'Изберете дата.'; // Fallback
                } else { // Минала дата
                    countdownEl.textContent = '--:--:--';
                    countdownTextEl.textContent = 'Избрана е минала дата.';
                }
                return; // Изход, тъй като това не е днешното обратно броене
            }

            // Ако selectedDate Е днешна дата, продължете с нормалната логика за обратно броене
            returnTodayBtn.classList.add('hidden'); // Скриване на бутона "Връщане към днес"

            if (Object.keys(prayerTimes).length === 0) {
                countdownEl.textContent = '--:--:--';
                countdownTextEl.textContent = 'Няма отброяване за избраната дата.';
                return;
            }

            let nextPrayerTimeDate;
            let nextPrayerDisplayName;

            // Използвайте вече подготвените prayersDataForDisplay, за да намерите следващия намаз
            // Няма нужда да извличате отново API данни тук
            
            let prayersArrayForCountdown = prayersDataForDisplay; // Използвайте глобално достъпните данни

            nextPrayerIndex = -1; 
            for (let i = 0; i < prayersArrayForCountdown.length; i++) {
                if (prayersArrayForCountdown[i].date > now) {
                    nextPrayerIndex = i;
                    break;
                    }
                }
            
            if (nextPrayerIndex === -1 && prayersArrayForCountdown.length > 0) {
                // Всички намази за днес са минали. Задайте nextPrayerIndex на 0 за обратно броене на Фаджр за утре.
                nextPrayerIndex = 0; 
                const nextDayFajr = new Date(prayersArrayForCountdown[0].date);
                nextDayFajr.setDate(nextDayFajr.getDate() + 1);
                nextPrayerTimeDate = nextDayFajr;
                nextPrayerDisplayName = prayersArrayForCountdown[0].displayName;
                countdownTextEl.textContent = `до ${nextPrayerDisplayName} утре`;
            } else if (nextPrayerIndex !== -1) {
                const nextPrayer = prayersArrayForCountdown[nextPrayerIndex];
                nextPrayerTimeDate = nextPrayer.date;
                nextPrayerDisplayName = nextPrayer.displayName;
                countdownTextEl.textContent = `до ${nextPrayerDisplayName}`;
            } else {
                countdownEl.textContent = '00:00:00';
                countdownTextEl.textContent = 'Всички намази за днес са минали.';
                return;
            }

            const diff = nextPrayerTimeDate.getTime() - now.getTime();

            if (diff <= 0) {
                countdownEl.textContent = '00:00:00';
                countdownTextEl.textContent = 'Намазът е сега!';
                fetchPrayerTimes(); 
                return;
            }

            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            countdownEl.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Функция за връщане към днешна дата
        function returnToToday() {
            selectedDate = new Date();
            hiddenDateInput.value = formatDateForInputAndLookup(selectedDate);
            fetchPrayerTimes(); // Извличане отново за показване на времената за днес
        }

        // --- Логика за модални прозорци ---

        // Глобален модален прозорец за корекции на намази
        function openAdjustmentModal() {
            prayerAdjustmentInputsContainer.innerHTML = ''; // Изчиства предишни входове
            const currentPrayerNames = getCurrentPrayerNames();

            allPrayerKeys.forEach(key => {
                const adjustmentValue = customPrayerAdjustments[key] !== undefined ? customPrayerAdjustments[key] : 0;
                const displayName = currentPrayerNames[key] || key; // Използвайте текущия език
                const dhuhrDisplayName = key === 'Dhuhr' ? getDhuhrName(new Date()) : displayName; // Специална обработка за Dhuhr

                const inputRow = document.createElement('div');
                inputRow.className = 'adjustment-input-row';
                inputRow.innerHTML = `
                    <label for="adj-${key}">${dhuhrDisplayName}:</label>
                    <input type="number" id="adj-${key}" data-prayer-key="${key}" value="${adjustmentValue}" class="shadow appearance-none border rounded-lg py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline bg-gray-600 border-gray-500 text-white" placeholder="Напр. 5 или -3">
                `;
                prayerAdjustmentInputsContainer.appendChild(inputRow);
            });
            
            adjustmentModal.classList.remove('hidden');
        }

        function closeAdjustmentModal() {
            adjustmentModal.classList.add('hidden');
            errorMessageEl.classList.add('hidden'); // Изчистване на съобщението за грешка при затваряне на модала
            closeSideMenu(); // Затваряне на страничното меню след взаимодействие с модала
        }

        function saveAllAdjustments() {
            let changesMade = false;
            allPrayerKeys.forEach(key => {
                const inputElement = document.getElementById(`adj-${key}`);
                if (inputElement) {
                    const newOffset = parseInt(inputElement.value, 10);
                    if (isNaN(newOffset)) {
                        errorMessageEl.textContent = `Невалидно число за корекция на ${getCurrentPrayerNames()[key] || key}. Моля, въведете валидно число (напр. 5 или -3).`;
                        errorMessageEl.classList.remove('hidden');
                        return; // Изход, ако някой вход е невалиден
                    }

                    if (customPrayerAdjustments[key] !== newOffset) {
                        customPrayerAdjustments[key] = newOffset;
                        changesMade = true;
                    }
                }
            });

            if (changesMade) {
                saveSettings(); // Автоматично запазване на всички актуализирани корекции
                fetchPrayerTimes(); // Извличане и показване отново с нови персонализирани корекции
            }
            closeAdjustmentModal();
        }


        // Функции за модален прозорец за избор на град
        function openCitySelectionModal() {
            populateCityList(); // Попълване на списъка преди отваряне
            citySelectionModal.classList.remove('hidden');
        }

        function closeCitySelectionModal() {
            citySelectionModal.classList.add('hidden');
        }

        // --- Функции за странично меню ---
        function openSideMenu() {
            sideMenu.classList.add('open');
            mainContentWrapper.style.transform = `translateX(${sideMenu.offsetWidth}px)`; // Избутване на основното съдържание
            document.body.style.overflow = 'hidden'; // Предотвратява превъртане на body
        }

        function closeSideMenu() {
            sideMenu.classList.remove('open');
            mainContentWrapper.style.transform = `translateX(0)`; // Връщане на основното съдържание
            document.body.style.overflow = ''; // Възстановява превъртането на body
        }

        // --- Swipe Logic Variables ---
        let startX = 0;
        let currentX = 0;
        let diffX = 0;
        let isSwiping = false;
        const swipeThreshold = 50; // pixels to swipe to trigger action

        // --- Event Listeners for Swipe ---
        // For opening the menu (swipe right on main content)
        mainContentWrapper.addEventListener('touchstart', (e) => {
            if (sideMenu.classList.contains('open')) return; // Only process if menu is closed
            startX = e.touches[0].clientX;
            isSwiping = true;
            mainContentWrapper.style.transition = 'none'; // Disable transition for smooth drag
            sideMenu.style.transition = 'none';
        });

        mainContentWrapper.addEventListener('touchmove', (e) => {
            if (!isSwiping || sideMenu.classList.contains('open')) return;
            currentX = e.touches[0].clientX;
            diffX = currentX - startX;

            if (diffX > 0) { // Swiping right
                e.preventDefault(); // Prevent page scrolling
                const transformX = Math.min(diffX, sideMenu.offsetWidth);
                mainContentWrapper.style.transform = `translateX(${transformX}px)`;
                sideMenu.style.transform = `translateX(${transformX - sideMenu.offsetWidth}px)`;
            }
        });

        mainContentWrapper.addEventListener('touchend', (e) => {
            if (!isSwiping || sideMenu.classList.contains('open')) return;
            isSwiping = false;
            mainContentWrapper.style.transition = ''; // Re-enable transition
            sideMenu.style.transition = '';

            if (diffX > swipeThreshold) { // If swiped enough to the right
                openSideMenu();
            } else { // Snap back to closed
                mainContentWrapper.style.transform = `translateX(0)`;
                sideMenu.style.transform = `translateX(-${sideMenu.offsetWidth}px)`;
            }
            diffX = 0; // Reset diffX
        });

        // For closing the menu (swipe left on side menu)
        sideMenu.addEventListener('touchstart', (e) => {
            if (!sideMenu.classList.contains('open')) return; // Only process if menu is open
            startX = e.touches[0].clientX;
            isSwiping = true;
            mainContentWrapper.style.transition = 'none'; // Disable transition for smooth drag
            sideMenu.style.transition = 'none';
        });

        sideMenu.addEventListener('touchmove', (e) => {
            if (!isSwiping || !sideMenu.classList.contains('open')) return;
            currentX = e.touches[0].clientX;
            diffX = currentX - startX;

            if (diffX < 0) { // Swiping left
                e.preventDefault(); // Prevent page scrolling
                const transformX = Math.max(diffX, -sideMenu.offsetWidth);
                mainContentWrapper.style.transform = `translateX(${sideMenu.offsetWidth + transformX}px)`;
                sideMenu.style.transform = `translateX(${transformX}px)`;
            }
        });

        sideMenu.addEventListener('touchend', (e) => {
            if (!isSwiping || !sideMenu.classList.contains('open')) return;
            isSwiping = false;
            mainContentWrapper.style.transition = ''; // Re-enable transition
            sideMenu.style.transition = '';

            if (diffX < -swipeThreshold) { // If swiped enough to the left
                closeSideMenu();
            } else { // Snap back to open
                mainContentWrapper.style.transform = `translateX(${sideMenu.offsetWidth}px)`;
                sideMenu.style.transform = `translateX(0)`;
            }
            diffX = 0; // Reset diffX
        });

        // --- Функции за локално хранилище ---
        function saveSettings() {
            const settingsToSave = {
                selectedCity: selectedCity,
                customPrayerAdjustments: customPrayerAdjustments,
                isClassicalNamesActive: isClassicalNamesActive
                // isCountdownMode умишлено НЕ се запазва в localStorage тук
            };
            try {
                localStorage.setItem('prayerApp_settings', JSON.stringify(settingsToSave));
                // По избор предоставяне на обратна връзка на потребителя:
                // console.log("Настройките запазени успешно!");
            } catch (e) {
                console.error("Неуспешно запазване на настройките в localStorage:", e);
                errorMessageEl.textContent = 'Неуспешно запазване на настройките.';
                errorMessageEl.classList.remove('hidden');
            }
        }

        function loadSettings() {
            try {
                const savedSettings = JSON.parse(localStorage.getItem('prayerApp_settings'));
                if (savedSettings) {
                    selectedCity = savedSettings.selectedCity || "София";
                    customPrayerAdjustments = savedSettings.customPrayerAdjustments || {};
                    isClassicalNamesActive = savedSettings.isClassicalNamesActive || false;
                    // isCountdownMode умишлено НЕ се зарежда от localStorage тук
                    
                    // Актуализиране на елемента за показване на града
                    selectedCityDisplay.textContent = selectedCity;
                }
                // Винаги задавайте selectedDate на днес при зареждане
                selectedDate = new Date(); 
                // Актуализиране на скрития input елемент, така че date picker да отразява днешната дата
                hiddenDateInput.value = formatDateForInputAndLookup(selectedDate);
            }
            catch (e) {
                console.error("Неуспешно зареждане на настройките от localStorage:", e);
                errorMessageEl.textContent = 'Възникна проблем при зареждане на настройките. Използват се настройки по подразбиране.';
                errorMessageEl.classList.remove('hidden');
                // По избор изчистване на повредени настройки, ако е необходимо: localStorage.removeItem('prayerApp_settings');
            }
        }

        // Първоначална настройка и периодични актуализации
        window.onload = function() {
            loadSettings(); // Първо заредете настройките
            
            updateClock(); // Стартирайте показването на текущото време
            fetchPrayerTimes(); // Първоначално извличане на времената за намаз с помощта на заредените настройки

            // Слушател на събитие за бутона Хамбургер за отваряне на страничното меню
            hamburgerMenuBtn.addEventListener('click', openSideMenu);
            // Слушател на събитие за бутона Затвори вътре в страничното меню
            closeSideMenuBtn.addEventListener('click', closeSideMenu);
            
            // Слушател на събитие за бутона за местоположение за отваряне на модалния прозорец за избор на град (вече вътре в страничното меню)
            locationSelectBtn.addEventListener('click', openCitySelectionModal);
            
            // Фиксиран слушател на събитие за затваряне на модала за град с помощта на бутона за затваряне
            closeCityModalBtn.addEventListener('click', closeCitySelectionModal);

            // Слушател на събитие за затваряне на модала за град чрез щракване върху overlay
            citySelectionModal.addEventListener('click', (event) => {
                // Проверете дали щракването е станало директно върху modal-overlay (не върху съдържанието му)
                if (event.target === citySelectionModal) {
                    closeCitySelectionModal();
                }
            });

            // Слушател на събитие за НОВИЯ бутон за превключване на обратно броене (вече вътре в страничното меню)
            countdownToggleButton.addEventListener('click', () => {
                isCountdownMode = !isCountdownMode;
                saveSettings(); // Запазване на новия режим (въпреки че не е постоянен за isCountdownMode)
                displayPrayerTimes(); // Показване отново на времената за намаз с новия режим
                closeSideMenu(); // Затваряне на страничното меню след изпълнение на действието
            });

            // Слушател на събитие за новия бутон за избор на дата, за да задейства скрития вход (вече вътре в страничното меню)
            datePickerBtn.addEventListener('click', (event) => { // Добавен параметър event
                hiddenDateInput.showPicker(); // Отваряне на нативния избор на дата
            });

            // Слушател на събитие за промяна на скрития вход за дата
            hiddenDateInput.addEventListener('change', (event) => {
                selectedDate = new Date(event.target.value);
                fetchPrayerTimes(); // Извличане отново на времената за новоизбраната дата
                closeSideMenu(); // Затваряне на страничното меню след избор на дата
            });

            // Слушател на събитие за бутона за превключване на езика (вече вътре в страничното меню)
            languageToggleBtn.addEventListener('click', (event) => { // Добавен параметър event
                isClassicalNamesActive = !isClassicalNamesActive;
                saveSettings(); // Автоматично запазване на предпочитанията за език
                fetchPrayerTimes(); // Извличане/показване отново за прилагане на новите имена
                closeSideMenu(); // Затваряне на страничното меню след изпълнение на действието
            });
            
            // Слушатели на събития за глобалния модален прозорец за корекции (вече вътре в страничното меню)
            openAdjustmentModalBtn.addEventListener('click', openAdjustmentModal);
            cancelAdjustmentBtn.addEventListener('click', closeAdjustmentModal);
            saveAllAdjustmentsBtn.addEventListener('click', saveAllAdjustments); 

            // Слушател на събитие за новия бутон "Връщане към днес"
            returnTodayBtn.addEventListener('click', returnToToday);

            // Актуализиране на часовника всяка секунда
            setInterval(updateClock, 1000);
            // Актуализиране на основното обратно броене всяка секунда (активно само за днешна дата или специфична логика за бъдеще/минало)
            setInterval(updateCountdown, 1000);
        };
    </script>
</body>
</html>
